#' Downscaler Modeling for Merging Point and Areal Data by SPDE
#' 
#' @param mesh A inla.mesh obj or NULL.
#' @param target A sf obj which includes the locations of target area. Generated by target().
#' @param prior.range A two-dimensional vector to construct SPDE. More information can be found inla.spde2.pcmatern()
#' @param prior.sigma A two-dimensional vector to construct SPDE. More information can be found inla.spde2.pcmatern()
#' @param p.sf A sf obj includes 'value.p' and 'geometry' columns, the point data
#' @param area.sf A sf obj includes 'value.a' and 'geometry' columns, the areal data
#' @return A dataframe with predicted mean, 95% credible interval of the prediction

source('mesh.R')
source('check.r')
source('prediction.R')
dwscaler.spde = function(mesh = NULL,target,areaPre.sf = NULL,
                         prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),
                         p.sf,area.sf){
  #check function
  check_dwscaler(area.sf, p.sf,target)
  
   # Match Areal data and point data, Match target and area.sf
  locin= st_join(p.sf,area.sf,left = F)
  locin_pred = st_join(target,area.sf,left = F)
  
  
  #Projection Matrix for point data and target area
  
  if(is.null(mesh) ==T){
    mesh = Mesh(area.sf)
    message("Generate mesh by default")
  }
  
  Ap = inla.spde.make.A(mesh, loc = as.matrix(st_coordinates(p.sf[,1]))[,c(1,2)])
  Apre = inla.spde.make.A(mesh = mesh, loc = as.matrix (st_coordinates(target[,1])))
  

  
  #construct SPDE
  spde = inla.spde2.pcmatern(
     mesh = mesh,
     prior.range = prior.range, 
     prior.sigma = prior.sigma) 
  
  # set formula
  formula <- y ~ 0 + b0  + X + f(s, model = spde)+f(s1,model= spde)
  indexs = inla.spde.make.index("s", spde$n.spde)
  indexs1 = inla.spde.make.index("s1", spde$n.spde)
  
  #construct stack
  stk.full = stack.full.ds(locin,Ap,Apre,locin_pred,indexs,indexs1)
  
  #estimation and prediction
  res <- inla(formula,
              data = inla.stack.data(stk.full),
              control.predictor = list(
                compute = TRUE,
                A = inla.stack.A(stk.full)
              ))
  
  #prediction data frame
  return(pred(res,stk.full,target,areaPre.sf,proN)) 

}


#*************Construct stack*************
stack.full.ds = function(locin,Ap,Apre,locin_pred,indexs,indexs1){
  stk.e <- inla.stack(
    tag = "est",
    data = list(y = locin$value.p),
    A = list(1,Ap*locin$value.a,Ap),
    effects = list(data.frame(b0 = rep(1, nrow(locin)),X = locin$value.a), s = indexs, s1 = indexs1)
  )
  
  # stack for prediction stk.p
  stk.p <- inla.stack(
    tag = "pred",
    data = list(y = NA),
    A = list(1, Apre*locin_pred$value.a,Apre),
    effects = list(data.frame(b0 = rep(1, nrow(locin_pred)), X= locin_pred$value.a), s = indexs, s1 = indexs1)
  )
  
  return(inla.stack(stk.e, stk.p))
}

