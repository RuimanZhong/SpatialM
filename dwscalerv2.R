#' Downscaler Modeling for Merging Point and Areal Data by SPDE
#'
#' @param mesh A inla.mesh obj or NULL.
#' @param dppoint A sf obj which includes the locations of dppoint area. Generated by dppoint().
#' @param prior.range A two-dimensional vector to construct SPDE. More information can be found inla.spde2.pcmatern()
#' @param prior.sigma A two-dimensional vector to construct SPDE. More information can be found inla.spde2.pcmatern()
#' @param depoint A sf obj includes 'value.p' and 'geometry' columns, the point data
#' @param dearea A sf obj includes 'value.a' and 'geometry' columns, the areal data
#' @return A dataframe with predicted mean, 95% credible interval of the prediction

source("fnCreateMesh.R")
source("fnCheckInputsDown.R")
source("prediction.R")
dwscaler.spde <- function(depoint, dearea, dppoint = NULL, dparea = NULL, boundaryregion,
                          mesh = NULL, priorspdesigma = NULL, priorspderange = NULL) {
  de1 <- depoint
  de2 <- dearea
  # datasets prediction
  dp1 <- dppoint
  dp2 <- dparea
  
  # check function
  fnCheckInputsDown(de1, de2, dp1, dp2, boundaryregion)

  # Match Areal data and point data, Match dppoint and dearea
  locin <- st_join(depoint, dearea, left = F)
  locin_pred <- st_join(dppoint, dearea, left = F)


  # Projection Matrix for point data and dppoint area

  if (is.null(mesh) == T) {
    mesh <- Mesh(dearea)
    message("Generate mesh by default")
  }

  Ap <- inla.spde.make.A(mesh, loc = as.matrix(st_coordinates(depoint[, 1]))[, c(1, 2)])
  Apre <- inla.spde.make.A(mesh = mesh, loc = as.matrix(st_coordinates(dppoint[, 1])))



  # construct SPDE
  spde <- inla.spde2.pcmatern(
    mesh = mesh,
    prior.range = prior.range,
    prior.sigma = prior.sigma
  )

  # set formula
  formula <- y ~ 0 + b0 + X + f(s, model = spde) + f(s1, model = spde)
  indexs <- inla.spde.make.index("s", spde$n.spde)
  indexs1 <- inla.spde.make.index("s1", spde$n.spde)

  # construct stack
  stk.full <- stack.full.ds(locin, Ap, Apre, locin_pred, indexs, indexs1)

  # estimation and prediction
  res <- inla(formula,
    data = inla.stack.data(stk.full),
    control.predictor = list(
      compute = TRUE,
      A = inla.stack.A(stk.full)
    )
  )

  # prediction data frame
  return(pred(res, stk.full, dppoint, dparea, proN))
}


#************* Construct stack*************
stack.full.ds <- function(locin, Ap, Apre, locin_pred, indexs, indexs1) {
  stk.e <- inla.stack(
    tag = "est",
    data = list(y = locin$value.p),
    A = list(1, Ap * locin$value.a, Ap),
    effects = list(data.frame(b0 = rep(1, nrow(locin)), X = locin$value.a), s = indexs, s1 = indexs1)
  )

  # stack for prediction stk.p
  stk.p <- inla.stack(
    tag = "pred",
    data = list(y = NA),
    A = list(1, Apre * locin_pred$value.a, Apre),
    effects = list(data.frame(b0 = rep(1, nrow(locin_pred)), X = locin_pred$value.a), s = indexs, s1 = indexs1)
  )

  return(inla.stack(stk.e, stk.p))
}
