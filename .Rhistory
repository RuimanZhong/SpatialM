dparea <- dearea
library(rgeoboundaries)
bd = geoboundaries("United Kingdom")
mesh = fnCreateMesh(depoint, NULL, bd = bd)
plot(mesh)
points(location,col =2)
location = as.matrix(st_coordinates(depoint)[ , c(1,2)])
mesh = fnCreateMesh(depoint, NULL, bd = bd)
plot(mesh)
points(location,col =2)
geopre = fnPredictMelding(depoint =  depoint, dearea = NULL, dppoint = dppoint, dparea = NULL, mesh = mesh)
fnPredictMelding <- function(depoint = NULL, dearea = NULL,
dppoint = NULL, dparea = NULL, mesh = NULL,
prior.range = NULL, prior.sigma = NULL){
# Use 1 for points and 2 for areas
# datasets estimation
de1 <- depoint
de2 <- dearea
# datasets prediction
dp1 <- dppoint
dp2 <- dparea
# check I pass at least de1 or de2 to fit the model
# check I pass at least dp1 or dp2 to predict
# check formats are OK
# check CRS points and areas are the same.
fnCheckInputsMelding(de1, de2, dp1, dp2)
# Logical values indicating what datasets I have
de1ToF <- !is.null(de1)
de2ToF <- !is.null(de2)
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
meshToF <- is.null(mesh)
spdeIndex <- is.null(prior.range)
# Create mesh using estimation points. TODO: construct mesh better
#locations <- cbind(de1$x, de1$y)
if(meshToF){mesh <- fnCreateMesh(de1,de2,bd)}
# Create spde and index
if(spdeIndex){
spde = inla.spde2.matern(mesh = mesh, alpha = 2, constr = T)
} else {
spde = inla.spde2.pcmatern(
mesh = mesh,
prior.range = prior.range,
prior.sigma = prior.sigma)
}
indexs <- inla.spde.make.index("s", spde$n.spde)
# Projection matrices for points (estimation point and prediction point)
if(de1ToF){Ae1 <- inla.spde.make.A(mesh = mesh, loc = as.matrix(st_coordinates(de1)[ , c(1,2)]))}
if(dp1ToF){Ap1 <- inla.spde.make.A(mesh = mesh, loc = as.matrix(st_coordinates(dp1)[ , c(1,2)]))}
# Create projection matrix A for areas (estimation area and prediction area)
if(de2ToF){Ae2 <- fnProjectionMatrixArea(de2, mesh)}
if(dp2ToF){Ap2 <- fnProjectionMatrixArea(dp2, mesh)}
# Create stk.full
message('Creating stack')
stk.e1 = NULL
stk.e2 = NULL
stk.p1 = NULL
stk.p2 = NULL
# estimation point (de1), estimation area (de2), prediction point (dp1), prediction area (dp2)
if(de1ToF){stk.e1 <- inla.stack(tag = "est1", data = list(y = de1$pvalue), A = list(1, Ae1), effects = list(data.frame(b0 = rep(1, nrow(de1))), s = indexs$s))}
if(de2ToF){stk.e2 <- inla.stack(tag = "est2", data = list(y = de2$avalue), A = list(1, Ae2), effects = list(data.frame(b0 = rep(1, nrow(de2))), s = indexs$s))}
if(dp1ToF){stk.p1 <- inla.stack(tag = "pred1", data = list(y = NA), A = list(1, Ap1), effects = list(data.frame(b0 = rep(1, nrow(dp1))), s = indexs$s))}
if(dp2ToF){stk.p2 <- inla.stack(tag = "pred2", data = list(y = NA), A = list(1, Ap2), effects = list(data.frame(b0 = rep(1, nrow(dp2))), s = indexs$s))}
# construct stack full with the data we have # stk.full <- inla.stack(stk.e1, stk.p1)
stk.full <- do.call(inla.stack, list(stk.e1, stk.e2, stk.p1, stk.p2)[c(de1ToF, de2ToF, dp1ToF, dp2ToF)])
# Specify formula melding
formula <- y ~ 0 + b0 + f(s, model = spde)
# Call inla()
res <- inla(formula, family = "gaussian", data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
# Retrieve predictions points
# Predictions points
if(dp1ToF){dp1 <- fnRetrievePredictions(stk.full, "pred1", dp1)}
# Predictions areas
if(dp2ToF){dp2 <- fnRetrievePredictions(stk.full, "pred2", dp2)}
return(list(dp1,dp2))
}
# dparea dataset prediction area
source('fncheck.R')
source('fnCreateMesh.R')
fnPredictMelding <- function(depoint = NULL, dearea = NULL,
dppoint = NULL, dparea = NULL, mesh = NULL,
prior.range = NULL, prior.sigma = NULL){
# Use 1 for points and 2 for areas
# datasets estimation
de1 <- depoint
de2 <- dearea
# datasets prediction
dp1 <- dppoint
dp2 <- dparea
# check I pass at least de1 or de2 to fit the model
# check I pass at least dp1 or dp2 to predict
# check formats are OK
# check CRS points and areas are the same.
fnCheckInputsMelding(de1, de2, dp1, dp2)
# Logical values indicating what datasets I have
de1ToF <- !is.null(de1)
de2ToF <- !is.null(de2)
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
meshToF <- is.null(mesh)
spdeIndex <- is.null(prior.range)
# Create mesh using estimation points. TODO: construct mesh better
#locations <- cbind(de1$x, de1$y)
if(meshToF){mesh <- fnCreateMesh(de1,de2,bd)}
# Create spde and index
if(spdeIndex){
spde = inla.spde2.matern(mesh = mesh, alpha = 2, constr = T)
} else {
spde = inla.spde2.pcmatern(
mesh = mesh,
prior.range = prior.range,
prior.sigma = prior.sigma)
}
indexs <- inla.spde.make.index("s", spde$n.spde)
# Projection matrices for points (estimation point and prediction point)
if(de1ToF){Ae1 <- inla.spde.make.A(mesh = mesh, loc = as.matrix(st_coordinates(de1)[ , c(1,2)]))}
if(dp1ToF){Ap1 <- inla.spde.make.A(mesh = mesh, loc = as.matrix(st_coordinates(dp1)[ , c(1,2)]))}
# Create projection matrix A for areas (estimation area and prediction area)
if(de2ToF){Ae2 <- fnProjectionMatrixArea(de2, mesh)}
if(dp2ToF){Ap2 <- fnProjectionMatrixArea(dp2, mesh)}
# Create stk.full
message('Creating stack')
stk.e1 = NULL
stk.e2 = NULL
stk.p1 = NULL
stk.p2 = NULL
# estimation point (de1), estimation area (de2), prediction point (dp1), prediction area (dp2)
if(de1ToF){stk.e1 <- inla.stack(tag = "est1", data = list(y = de1$pvalue), A = list(1, Ae1), effects = list(data.frame(b0 = rep(1, nrow(de1))), s = indexs$s))}
if(de2ToF){stk.e2 <- inla.stack(tag = "est2", data = list(y = de2$avalue), A = list(1, Ae2), effects = list(data.frame(b0 = rep(1, nrow(de2))), s = indexs$s))}
if(dp1ToF){stk.p1 <- inla.stack(tag = "pred1", data = list(y = NA), A = list(1, Ap1), effects = list(data.frame(b0 = rep(1, nrow(dp1))), s = indexs$s))}
if(dp2ToF){stk.p2 <- inla.stack(tag = "pred2", data = list(y = NA), A = list(1, Ap2), effects = list(data.frame(b0 = rep(1, nrow(dp2))), s = indexs$s))}
# construct stack full with the data we have # stk.full <- inla.stack(stk.e1, stk.p1)
stk.full <- do.call(inla.stack, list(stk.e1, stk.e2, stk.p1, stk.p2)[c(de1ToF, de2ToF, dp1ToF, dp2ToF)])
# Specify formula melding
formula <- y ~ 0 + b0 + f(s, model = spde)
# Call inla()
res <- inla(formula, family = "gaussian", data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
# Retrieve predictions points
# Predictions points
if(dp1ToF){dp1 <- fnRetrievePredictions(stk.full, "pred1", dp1)}
# Predictions areas
if(dp2ToF){dp2 <- fnRetrievePredictions(stk.full, "pred2", dp2)}
return(list(dp1,dp2))
}
#####################################################################
# END MAIN FUNCTION
#####################################################################
#####################################################################
# INI AUXILIARY FUNCTIONS
#####################################################################
# Check inputs are correct. TODO: this function
# fnCheckInputsMelding <- function(de1, de2, dp1, dp2){
#
# }
# Create mesh. TODO: default values for max.edge and cutoff
# fnCreateMesh <- function(locations){
#   mesh <- inla.mesh.2d(loc = locations, max.edge = c(0.1, 5), cutoff = 0.01)
#   return(mesh)
# }
# Create projection matrix A for areas.
fnProjectionMatrixArea <- function(de2, mesh){
message('Creating areal projection matrix')
meshcoo = data.frame(X = mesh$loc[,1], Y = mesh$loc[,2])
meshin = meshcoo %>%
st_as_sf(coords = c("X", "Y"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
# find points in mesh n area.sf
locin= st_join(meshin, de2, left = F)
block <- rep(0, nrow(locin))
for(i in 1:nrow(de2)) {
block[as.vector(which(!is.na(st_join(locin, de2[i,], left = T)$avalue.y)))] <- i
}
A <- inla.spde.make.A(mesh=mesh,
loc=as.matrix(st_coordinates(locin[,1]))[,c(1,2)],
block=block,
block.rescale="sum")
return(A)
}
# Create stk.full
# fnCreateStack <- function(de1ToF, de2ToF, dp1ToF, dp2ToF, de1, de2, dp1, dp2){
#   message('Creating stack')
#    stk.e1 = NULL
#    stk.e2 = NULL
#    stk.p1 = NULL
#    stk.p2 = NULL
#
#    # estimation point (de1), estimation area (de2), prediction point (dp1), prediction area (dp2)
#   if(de1ToF){stk.e1 <- inla.stack(tag = "est1", data = list(y = de1$pvalue), A = list(1, Ae1), effects = list(data.frame(b0 = rep(1, nrow(de1))), s = indexs$s))}
#   if(de2ToF){stk.e2 <- inla.stack(tag = "est2", data = list(y = de2$avalue), A = list(1, Ae2), effects = list(data.frame(b0 = rep(1, nrow(de2))), s = indexs$s))}
#   if(dp1ToF){stk.p1 <- inla.stack(tag = "pred1", data = list(y = NA), A = list(1, Ap1), effects = list(data.frame(b0 = rep(1, nrow(dp1))), s = indexs$s))}
#   if(dp2ToF){stk.p2 <- inla.stack(tag = "pred2", data = list(y = NA), A = list(1, Ap2), effects = list(data.frame(b0 = rep(1, nrow(dp2))), s = indexs$s))}
#   # construct stack full with the data we have # stk.full <- inla.stack(stk.e1, stk.p1)
#   stk.full <- do.call(inla.stack, list(stk.e1, stk.e2, stk.p1, stk.p2)[c(de1ToF, de2ToF, dp1ToF, dp2ToF)])
#   return(stk.full)
# }
# Retrieve predictions
fnRetrievePredictions <- function(stack, tag, dataset){
index <- inla.stack.index(stack = stack, tag = tag)$data
# dataset$pred_mean <- res$summary.fitted.values[index, "mean"]
# dataset$pred_ll <- res$summary.fitted.values[index, "0.025quant"]
# dataset$pred_ul <- res$summary.fitted.values[index, "0.975quant"]
return(index)
}
#####################################################################
# END AUXILIARY FUNCTIONS
#####################################################################
geopre = fnPredictMelding(depoint =  depoint, dearea = NULL, dppoint = dppoint, dparea = NULL, mesh = mesh)
ggplot(data = bd) + geom_sf() + geom_sf(data = geopre[[1]],aes(geometry = geometry,color=pred_mean))
View(geopre)
geopre[[1]]
de1 <- depoint
dp1 <- dppoint
dearea = NULL
dparea = NULL
# Logical values indicating what datasets I have
de1ToF <- !is.null(de1)
de2ToF <- !is.null(de2)
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
meshToF <- is.null(mesh)
prior.range = NULL
de1ToF <- !is.null(de1)
de2ToF <- !is.null(de2)
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
meshToF <- is.null(mesh)
spdeIndex <- is.null(prior.range)
if(meshToF){mesh <- fnCreateMesh(de1,de2,bd)}
# Create spde and index
if(spdeIndex){
spde = inla.spde2.matern(mesh = mesh, alpha = 2, constr = T)
} else {
spde = inla.spde2.pcmatern(
mesh = mesh,
prior.range = prior.range,
prior.sigma = prior.sigma)
}
indexs <- inla.spde.make.index("s", spde$n.spde)
# Projection matrices for points (estimation point and prediction point)
if(de1ToF){Ae1 <- inla.spde.make.A(mesh = mesh, loc = as.matrix(st_coordinates(de1)[ , c(1,2)]))}
if(dp1ToF){Ap1 <- inla.spde.make.A(mesh = mesh, loc = as.matrix(st_coordinates(dp1)[ , c(1,2)]))}
# Create projection matrix A for areas (estimation area and prediction area)
if(de2ToF){Ae2 <- fnProjectionMatrixArea(de2, mesh)}
if(dp2ToF){Ap2 <- fnProjectionMatrixArea(dp2, mesh)}
de1ToF <- !is.null(de1)
de2ToF <- !is.null(de2)
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
meshToF <- is.null(mesh)
spdeIndex <- is.null(prior.range)
de1 <- depoint
de2 <- dearea
# datasets prediction
dp1 <- dppoint
dp2 <- dparea
fnCheckInputsMelding(de1, de2, dp1, dp2)
# Logical values indicating what datasets I have
de1ToF <- !is.null(de1)
de2ToF <- !is.null(de2)
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
meshToF <- is.null(mesh)
spdeIndex <- is.null(prior.range)
if(meshToF){mesh <- fnCreateMesh(de1,de2,bd)}
# Create spde and index
if(spdeIndex){
spde = inla.spde2.matern(mesh = mesh, alpha = 2, constr = T)
} else {
spde = inla.spde2.pcmatern(
mesh = mesh,
prior.range = prior.range,
prior.sigma = prior.sigma)
}
indexs <- inla.spde.make.index("s", spde$n.spde)
# Projection matrices for points (estimation point and prediction point)
if(de1ToF){Ae1 <- inla.spde.make.A(mesh = mesh, loc = as.matrix(st_coordinates(de1)[ , c(1,2)]))}
if(dp1ToF){Ap1 <- inla.spde.make.A(mesh = mesh, loc = as.matrix(st_coordinates(dp1)[ , c(1,2)]))}
# Create projection matrix A for areas (estimation area and prediction area)
if(de2ToF){Ae2 <- fnProjectionMatrixArea(de2, mesh)}
if(dp2ToF){Ap2 <- fnProjectionMatrixArea(dp2, mesh)}
stk.e1 = NULL
stk.e2 = NULL
stk.p1 = NULL
stk.p2 = NULL
# estimation point (de1), estimation area (de2), prediction point (dp1), prediction area (dp2)
if(de1ToF){stk.e1 <- inla.stack(tag = "est1", data = list(y = de1$pvalue), A = list(1, Ae1), effects = list(data.frame(b0 = rep(1, nrow(de1))), s = indexs$s))}
if(de2ToF){stk.e2 <- inla.stack(tag = "est2", data = list(y = de2$avalue), A = list(1, Ae2), effects = list(data.frame(b0 = rep(1, nrow(de2))), s = indexs$s))}
if(dp1ToF){stk.p1 <- inla.stack(tag = "pred1", data = list(y = NA), A = list(1, Ap1), effects = list(data.frame(b0 = rep(1, nrow(dp1))), s = indexs$s))}
if(dp2ToF){stk.p2 <- inla.stack(tag = "pred2", data = list(y = NA), A = list(1, Ap2), effects = list(data.frame(b0 = rep(1, nrow(dp2))), s = indexs$s))}
# construct stack full with the data we have # stk.full <- inla.stack(stk.e1, stk.p1)
stk.full <- do.call(inla.stack, list(stk.e1, stk.e2, stk.p1, stk.p2)[c(de1ToF, de2ToF, dp1ToF, dp2ToF)])
formula <- y ~ 0 + b0 + f(s, model = spde)
# Call inla()
res <- inla(formula, family = "gaussian", data = inla.stack.data(stk.full),
control.predictor = list(compute = TRUE, link = 1, A = inla.stack.A(stk.full)))
if(dp1ToF){dp1 <- fnRetrievePredictions(stk.full, "pred1", dp1)}
if(dp1ToF){dp1 <- fnRetrievePredictions(stk.full, res, "pred1", dp1)}
# Retrieve predictions
fnRetrievePredictions <- function(stack, res, tag, dataset){
index <- inla.stack.index(stack = stack, tag = tag)$data
dataset$pred_mean <- res$summary.fitted.values[index, "mean"]
dataset$pred_ll <- res$summary.fitted.values[index, "0.025quant"]
dataset$pred_ul <- res$summary.fitted.values[index, "0.975quant"]
return(dataset)
}
# Retrieve predictions points
# Predictions points
if(dp1ToF){dp1 <- fnRetrievePredictions(stk.full, res, "pred1", dp1)}
# Predictions areas
if(dp2ToF){dp2 <- fnRetrievePredictions(stk.full, res, "pred2", dp2)}
View(dp1)
index <- inla.stack.index(stack = stack, tag = tag)$data
if(dp1ToF){dp1 <- fnRetrievePredictions(stk.full, res, "pred1", dp1)}
View(dp1)
dp1 <- dppoint
dep1$pred_mean <- res$summary.fitted.values[index, "mean"]
index <- inla.stack.index(stack = stack, tag = tag)$data
stack = stk.full
tag = 'pred'
tag = 'pred1'
index <- inla.stack.index(stack = stack, tag = tag)$data
dp1$pred_mean <- res$summary.fitted.values[index, "mean"]
View(dp1)
# Retrieve predictions
fnRetrievePredictions <- function(stack, res, tag, dataset){
index <- inla.stack.index(stack = stack, tag = tag)$data
dataset$pred_mean <- res$summary.fitted.values[index, "mean"]
dataset$pred_ll <- res$summary.fitted.values[index, "0.025quant"]
dataset$pred_ul <- res$summary.fitted.values[index, "0.975quant"]
return(dataset)
}
dp1 <- fnRetrievePredictions(stk.full, res, "pred1", dp1)
if(dp1ToF){dp1 <- fnRetrievePredictions(stk.full, res, "pred1", dp1)}
View(dp1)
dp1 <- dppoint
View(dp1)
if(dp1ToF){dp1 <- fnRetrievePredictions(stk.full, res, "pred1", dp1)}
setwd("~/Documents/Project 1/resources/sptialM/arealdata")
dearea = st_read('dearea.shp')
ggplot(data = dearea) +
geom_sf(aes(fill = avalue))
setwd("~/Documents/Project 1/data")
#st_transform(bd.sf, proN)
p.df = read.csv("2016PM2.5_avg.csv")
p.df = p.df[,c(2,3,4)]
colnames(p.df)<-c('pvalue','y','x')
depoint = p.df %>%
st_as_sf(coords = c("x", "y"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
proN = 4326
setwd("~/Documents/Project 1/data")
#st_transform(bd.sf, proN)
p.df = read.csv("2016PM2.5_avg.csv")
p.df = p.df[,c(2,3,4)]
colnames(p.df)<-c('pvalue','y','x')
depoint = p.df %>%
st_as_sf(coords = c("x", "y"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
head(depoint)
dppoint <- depoint
dparea <- dearea
library(rgeoboundaries)
bd = geoboundaries("United Kingdom")
location = as.matrix(st_coordinates(depoint)[ , c(1,2)])
mesh = fnCreateMesh(depoint, NULL, bd = bd)
source('fnPredictMelding.r')
location = as.matrix(st_coordinates(depoint)[ , c(1,2)])
mesh = fnCreateMesh(depoint, NULL, bd = bd)
plot(mesh)
points(location,col =2)
geopre = fnPredictMelding(depoint =  depoint, dearea = NULL, dppoint = dppoint, dparea = NULL, mesh = mesh)
ggplot(data = bd) + geom_sf() + geom_sf(data = geopre[[1]],aes(geometry = geometry,color=pred_mean))
mesh2 = fnCreateMesh(depoint = NULL,dearea, bd = bd)
arealpre = fnPredictMelding(depoint =  NULL, dearea = dearea, dppoint = NULL, dparea = dparea, mesh = mesh2)
View(arealpre)
ggplot(data = bd) + geom_sf() + geom_sf(data = geopre[[1]],aes(geometry = geometry,color=pred_mean))
ggplot(data = bd) + geom_sf() + geom_sf(data = arealpre [[2]],aes(geometry = geometry,color=pred_mean))
arealpre [[2]]
ggplot() +
geom_sf(data = arealpre [[2]], aes(geometry = geometry, fill = pred_mean)) +
geom_sf(data = bd, inherit.aes = FALSE, fill = NA) +
scale_fill_viridis() +
theme_minimal() +
labs(title = "Average Pm 2.5  Level 2016, UK", fill = "PM 2.5")
ggplot(data = bd) + geom_sf() + geom_sf(data = geopre[[1]],aes(geometry = geometry,color=pred_mean))+
labs(title = "Average Pm 2.5  Level 2016, UK", fill = "PM 2.5")
mesh_meld = fnCreateMesh(depoint = depoint,dearea, bd = bd)
mesh_meld = fnCreateMesh(depoint = depoint,dearea, bd = bd)
plot(mesh_meld)
mesh_meld = fnCreateMesh(depoint = depoint,dearea, bd = bd)
meldpre = fnPredictMelding(depoint =  depoint, dearea = dearea, dppoint = dppoint, dparea = dparea, mesh = mesh_meld)
head(meldpre[[2]])
mesh_meld = fnCreateMesh(depoint = depoint,dearea, bd = bd)
meldpre = fnPredictMelding(depoint =  depoint, dearea = dearea, dppoint = dppoint, dparea = dparea, mesh = mesh_meld)
head(meldpre[[2]])
head(arealpre[[2]])
meldpre[[2]]
head(geopre[[1]])
plot(1:74, geopre[[1]]$pvalue)
plot(1:74, geopre[[1]]$pvalue)
points(1:74, geopre[[1]]$pred_mean, col = red)
plot(1:74, geopre[[1]]$pvalue)
points(1:74, geopre[[1]]$pred_mean, col = 2)
plot(1:74, geopre[[1]]$pvalue)
lines(1:74, geopre[[1]]$pred_mean, col = 2)
# points()
plot(1:74, geopre[[1]]$pvalue)
lines(1:74, geopre[[1]]$pred_mean, col = 2)
lines(1:74, meldpre[[1]]$pred_mean, col = 2)
plot(1:74, geopre[[1]]$pvalue)
lines(1:74, geopre[[1]]$pred_mean, col = 2)
lines(1:74, meldpre[[1]]$pred_mean, col = 3)
plot(1:74, geopre[[1]]$pvalue)
lines(1:74, geopre[[1]]$pred_mean, col = 2)
lines(1:74, meldpre[[1]]$pred_mean, col = 3)
legend('bottomright', c('Melding','Geo'),lty = 1, col = c(3,2) )
c(class(depoint)[[1]],class(dppoint)[[1]],
class(dparea)[[1]],class(dearea)[[1]]) %!in% c("sf", "NULL")
class(bd) %!in% c("sf", "NULL")
class(bd) %in% c("sf", "NULL")
c(class(depoint)[[1]],class(dppoint)[[1]],
class(dparea)[[1]],class(dearea)[[1]]) %in% c("sf", "NULL")
class(bd) %in% c("sf", "NULL")
class(bd[1]) %in% c("sf", "NULL")
class(bd)[1] %in% c("sf", "NULL")
st_join(dearea,bd)
bd
nrow(dearea)
nrow(st_join(dearea,bd))
st_join(bd,dearea)
st_within(dparea,bd)
st_within(dparea,bd)
st_within(bd,dparea)
is.null(dearea) == F && nrow(dparea) !=  nrow(st_join(dparea,bd)
nrow(dparea) !=  nrow(st_join(dparea,bd))
nrow(dparea)
nrow(st_join(dparea,bd))
if(is.null(dearea) == F && nrow(dparea) !=  nrow(st_join(dparea,bd))){
stop("predicted area should be within boundary")
}
if(is.null(dppoint) == F && nrow(dppoint) !=  nrow(st_join(dppoint,bd))) stop("predicted area should be within boundary")
de1 <- depoint
de2 <- dearea
# datasets prediction
dp1 <- dppoint
dp2 <- dparea
# check I pass at least de1 or de2 to fit the model
# check I pass at least dp1 or dp2 to predict
# check formats are OK
# check CRS points and areas are the same.
fnCheckInputsMelding(de1, de2, dp1, dp2, bd)
fnCheckInputsMelding = function(depoint, dearea, dppoint, dparea, bd) {
if (is.null(dearea) == T && is.null(depoint) == T) stop("'Valid estimation data input required'")
if (is.null(dparea) == T && is.null(dppoint) == T) stop("'Valid preidction data input required'")
if(sum(c(class(depoint)[[1]],class(dppoint)[[1]],
class(dparea)[[1]],class(dearea)[[1]]) %in% c("sf", "NULL")) != 4)
stop("'All input data should be 'sf' obj")
if(is.null(depoint) == F && sum(c("pvalue", "geometry") %in% colnames(depoint)) != 2 )
stop("'depoint' must have 'geometry','pvalue' as column names")
if(is.null(dearea) == F && sum(c("avalue", "geometry") %in% colnames(dearea)) != 2 )
stop("'dearea' must have 'avalue','geometry', as column names")
if(st_crs(depoint) != st_crs(dearea) && sum(c(is.null(depoint),is.null(dearea))) == 0){
stop('all the input data must have the same crs, use st_crs() to check your data')
}
if(is.null(dparea) == F  && sum(c(st_crs(dparea) == st_crs(depoint),st_crs(dparea) == st_crs(dearea))) == 0){
stop('all the input data must have the same crs, use st_crs() to check your data')
}
if(is.null(dppoint) == F && sum(c(st_crs(dppoint) == st_crs(depoint),st_crs(dppoint) == st_crs(dearea))) == 0){
stop('all the input data must have the same crs, use st_crs() to check your data')
}
}
de1 <- depoint
de2 <- dearea
# datasets prediction
dp1 <- dppoint
dp2 <- dparea
# check I pass at least de1 or de2 to fit the model
# check I pass at least dp1 or dp2 to predict
# check formats are OK
# check CRS points and areas are the same.
fnCheckInputsMelding(de1, de2, dp1, dp2, bd)
location = as.matrix(st_coordinates(depoint)[ , c(1,2)])
packages = c('raster','rgdal',
'rnaturalearth',
'viridis','rnaturalearthhires','sf','INLA','rgeoboundaries','tidyverse')
package.check = lapply(packages, FUN =function(x){
if(!require(x ,character.only = T))
install.packages(x)
if(!(x %in% ( .packages()  ) ) )
library(x ,character.only = T)})
#source('fnPredictMelding.r')
proN = 4326
#setwd("~/Documents/Project 1/resources/sptialM")
p.df = read.csv("pointdata.csv")
p.df = p.df[,c(2,3,4)]
colnames(p.df)<-c('pvalue','y','x')
depoint = p.df %>%
st_as_sf(coords = c("x", "y"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
head(depoint)
dppoint <- depoint
dparea <- dearea
location = as.matrix(st_coordinates(depoint)[ , c(1,2)])
mesh = fnCreateMesh(depoint, NULL, bd = bd)
plot(mesh)
points(location,col =2)
