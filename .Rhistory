population = pennLC$data$population,
cases = pennLC$data$cases, n.strata = 16
)
library(dplyr)
d <- group_by(pennLC$data, county) %>% summarize(Y = sum(cases))
head(d)
d <- aggregate(
x = pennLC$data$cases,
by = list(county = pennLC$data$county),
FUN = sum
)
names(d) <- c("county", "Y")
pennLC$data <- pennLC$data[order(
pennLC$data$county,
pennLC$data$race,
pennLC$data$gender,
pennLC$data$age
), ]
E <- expected(
population = pennLC$data$population,
cases = pennLC$data$cases, n.strata = 16
)
d$E <- E[match(d$county, unique(pennLC$data$county))]
head(d)
d$SIR <- d$Y / d$E
map <- merge(map, d)
mapsf <- st_as_sf(map)
ggplot(mapsf) + geom_sf(aes(fill = SIR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red"
) +
theme_bw()
formula <- Y ~
f(idareau, model = "besag", graph = g, scale.model = TRUE) +
f(idareav, model = "iid")
knitr::opts_chunk$set(echo = TRUE)
map$idarea <- 1:nrow(map@data)
prior <- list(
prec = list(
prior = "pc.prec",
param = c(0.5 / 0.31, 0.01)),
phi = list(
prior = "pc",
param = c(0.5, 2 / 3))
)
library(spdep)
nb <- poly2nb(map)
head(nb)
#install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
library(SpatialEpi)
library(spdep)
library(sf)
res <- inla(formula,
family = "poisson", data = map@data,
E = E, control.predictor = list(compute = TRUE)
)
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")
formula <- Y ~ f(idarea, model = "bym2", graph = g, hyper = prior)
res <- inla(formula,
family = "poisson", data = map@data,
E = E, control.predictor = list(compute = TRUE)
)
summary(res)
#summaries of the relative risks including the mean posterior and the lower and upper limits of 95% credible intervals of the relative risks
head(res$summary.fitted.values)
map$RR <- res$summary.fitted.values[, "mean"]
map$LL <- res$summary.fitted.values[, "0.025quant"]
map$UL <- res$summary.fitted.values[, "0.975quant"]
summary(map@data[, c("RR", "LL", "UL")])
map$RR <- res$summary.fitted.values[, "mean"]
map$LL <- res$summary.fitted.values[, "0.025quant"]
map$UL <- res$summary.fitted.values[, "0.975quant"]
summary(map@data[, c("RR", "LL", "UL")])
mapsf <- st_as_sf(map)
gRR <- ggplot(mapsf) + geom_sf(aes(fill = RR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
#install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
library(SpatialEpi)
library(spdep)
library(sf)
library(ggplot2)
map$RR <- res$summary.fitted.values[, "mean"]
map$LL <- res$summary.fitted.values[, "0.025quant"]
map$UL <- res$summary.fitted.values[, "0.975quant"]
summary(map@data[, c("RR", "LL", "UL")])
mapsf <- st_as_sf(map)
gRR <- ggplot(mapsf) + geom_sf(aes(fill = RR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
gRR <- ggplot(mapsf) + geom_sf(aes(fill = RR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
map$RR <- res$summary.fitted.values[, "mean"]
map$LL <- res$summary.fitted.values[, "0.025quant"]
map$UL <- res$summary.fitted.values[, "0.975quant"]
summary(map@data[, c("RR", "LL", "UL")])
mapsf <- st_as_sf(map)
gRR <- ggplot(mapsf) + geom_sf(aes(fill = RR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
gUL <- ggplot(mapsf) + geom_sf(aes(fill = UL)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
gLL <- ggplot(mapsf) + geom_sf(aes(fill = LL)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
library(cowplot)
library(cowplot)
plot_grid(gRR, gLL, gUL, ncol = 1)
plot_grid(gRR, gLL, gUL, ncol = 1)
mapsf$re <- res$summary.random$idarea[1:67, "mean"]
ggplot(mapsf) + geom_sf(aes(fill = re)) +
scale_fill_gradient2(
midpoint = 0, low = "blue", mid = "white", high = "red"
) +
theme_bw()
knitr::opts_chunk$set(echo = TRUE)
library(geoR)
install.packages("geoR")
library(geoR)
library(geoR)
library(geoR)
install.packages("RandomFieldsUtils")
install.packages("RandomFieldsUtils")
knitr::opts_chunk$set(echo = TRUE)
#install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
library(SpatialEpi)
library(spdep)
library(sf)
library(ggplot2)
map <- pennLC$spatial.polygon
plot(map)
nb <- poly2nb(map)
head(nb) # output neighbors of each location
# set elements of spatial neighborhood matrices (choose 2, 44, 58)
d <- data.frame(county = names(map), neigh = rep(0, length(map)))
rownames(d) <- names(map)
map <- SpatialPolygonsDataFrame(map, d, match.ID = TRUE)
map$neigh[nb[[2]]] <- 1
map$neigh[nb[[44]]] <- 1
map$neigh[nb[[58]]] <- 1
#
coord <- coordinates(map)
map$long <- coord[, 1]
map$lat <- coord[, 2]
map$ID <- 1:dim(map@data)[1]
mapsf <- st_as_sf(map)
library(ggplot2)
ggplot(mapsf) + geom_sf(aes(fill = as.factor(neigh))) +
geom_text(aes(long, lat, label = ID), color = "white") +
theme_bw() + guides(fill = FALSE)
library(dplyr)
d <- group_by(pennLC$data, county) %>% summarize(Y = sum(cases))
head(d)
d <- aggregate(
x = pennLC$data$cases,
by = list(county = pennLC$data$county),
FUN = sum
)
names(d) <- c("county", "Y")
pennLC$data <- pennLC$data[order(
pennLC$data$county,
pennLC$data$race,
pennLC$data$gender,
pennLC$data$age
), ]
E <- expected(
population = pennLC$data$population,
cases = pennLC$data$cases, n.strata = 16
)
d$E <- E[match(d$county, unique(pennLC$data$county))]
head(d)
d$SIR <- d$Y / d$E
map <- merge(map, d)
mapsf <- st_as_sf(map)
ggplot(mapsf) + geom_sf(aes(fill = SIR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red"
) +
theme_bw()
formula <- Y ~
f(idareau, model = "besag", graph = g, scale.model = TRUE) +
f(idareav, model = "iid")
formula <- Y ~ f(idarea, model = "bym2", graph = g)
map$idarea <- 1:nrow(map@data)
prior <- list(
prec = list(
prior = "pc.prec",
param = c(0.5 / 0.31, 0.01)),
phi = list(
prior = "pc",
param = c(0.5, 2 / 3))
)
nb <- poly2nb(map)
head(nb)
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")
formula <- Y ~ f(idarea, model = "bym2", graph = g, hyper = prior)
res <- inla(formula,
family = "poisson", data = map@data,
E = E, control.predictor = list(compute = TRUE)
)
summary(res)
#summaries of the relative risks including the mean posterior and the lower and upper limits of 95% credible intervals of the relative risks
head(res$summary.fitted.values)
res$marginals.fitted.values
res$marginals.fitted.values
knitr::opts_chunk$set(echo = TRUE)
library(geoR)
library(geoR)
install.packages("RandomFieldsUtils")
# summary(res)
#summaries of the relative risks including the mean posterior and the lower and upper limits of 95% credible intervals of the relative risks
# head(res$summary.fitted.values)
res$marginals.fitted.values
View(res)
map$idarea <- 1:nrow(map@data)
prior <- list(
prec = list(
prior = "pc.prec",
param = c(0.5 / 0.31, 0.01)),
phi = list(
prior = "pc",
param = c(0.5, 2 / 3))
)
nb <- poly2nb(map)
head(nb)
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")
formula <- Y ~ f(idarea, model = "bym2", graph = g, hyper = prior)
res <- inla(formula,
family = "poisson", data = map@data,
E = E, control.predictor = list(compute = TRUE)
)
seq(from = 1, to = 100, by = 5)
rep(c(1,2,3,4), 3)
rep(c(1,2,3,4),each = 2)
seq(from = 1, length.out = 3)
data = seq(from = 1, to = 100, by = 5)
sample(data, 10)
sample(data, 10, replace = T)
options(digits=2)
sample(data, 10, replace = T)
x = 12.3545435
x
options(digits=2)
x
options(digits=8)
x = 12.3545435
x
y = c("a")
paste(x,y)
x = 12
paste(x,y)
paste0(x,y)
alphabet = paste0(LETTERS)
if (!require(openair)) {
install.packages("openair")
library(openair)
}
library(openair)
selected_data <- meta_data %>%
filter(variable == "PM2.5")
library(dplyr)
library(tidyverse)
meta_data <- importMeta(source = "aurn", all = TRUE)
head(meta_data, 3)
selected_data <- meta_data %>%
filter(variable == "PM2.5")
head(selected_data, 3)
View(selected_data)
gender = factor(c('female','male','unkown','female','male'),levels = c('male','female','unknown'))
library(dyplr)
library(dplyr)
library(tidyverse)
gneder2 = gender[gender ! = 'male']
gneder2 = gender[gender != 'male']
summary(gender2)
gender2 = gender[gender != 'male']
summary(gender2)
gender = factor(c('female','male','unknown','female','male'),levels = c('male','female','unknown'))
gender2 = gender[gender != 'male']
summary(gender2)
droplevels(gender2)
m2 <- matrix(1:12, nrow = 4, ncol = 3)
m2
rownames(m2) <- c("row1", "row2", "row3", "row4")
colnames(m2) <- c("col1", "col2", "col3")
#simplifying results in a named vector
m2[, 2]
which(is.na(df))
# Dataframe
df <- data.frame(col1 = 1:3,
col2 = c("this", "is", "text"),
col3 = c(TRUE, FALSE, TRUE),
col4 = c(2.5, 4.2, pi))
which(is.na(df))
which(is.na(df$col4))
# location of NA / how to find NA
x = as.vector(df$col4)
which(is.na(x))
# location of NA / how to find NA
colSums(is.na(df))
# location of NA / how to find NA
colSums(is.na(df))
# Dataframe
df <- data.frame(col1 = c(1:3, NA),
col2 = c("this", NA,"is", "text"),
col3 = c(TRUE, FALSE, TRUE, TRUE),
col4 = c(2.5, 4.2, 3.2, NA),
stringsAsFactors = FALSE)
# location of NA / how to find NA
colSums(is.na(df))
5/0
0/0
citation("dygraphs")
install.packages("dygraphs")
citation("dygraphs")
citation("plotly")
source('mesh.R')
setwd("~/Documents/Project 1/resources/sptialM")
source('mesh.R')
source('check.r')
setwd("~/Documents/Project 1/data")
# point data, load the data when wd is on data
p.df <- read.csv("2016PM2.5_avg.csv")
colnames(p.df)<-('px','py','value.p')
colnames(p.df)<-c('px','py','value.p')
View(p.df)
# point data, load the data when wd is on data
p.df <- read.csv("2016PM2.5_avg.csv")
p.df = p.df[,c(2,3,4)]
colnames(p.df)<-c('px','py','value.p')
View(p.df)
class(p.df)
proN = 27700
packages = c('raster','rgdal',
'rnaturalearth',
'viridis','rnaturalearthhires','sf','INLA','rgeoboundaries','tidyverse')
package.check = lapply(packages, FUN =function(x){
if(!require(x ,character.only = T))
install.packages(x)
if(!(x %in% ( .packages()  ) ) )
library(x ,character.only = T)})
p.sf = p.df %>%
st_as_sf(coords = c("px", "py"), dim = "XY") %>%
st_set_crs(ProN) %>%
st_cast("MULTIPOINT")
p.sf = p.df %>%
st_as_sf(coords = c("px", "py"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
View(p.sf)
View(p.df)
# area data, load the data when wd is on data
str_name<-'gwr_pm25_2016.tif'
setwd("~/Documents/Project 1/data/area_2016_pm2.5")
glo_pm = raster(str_name)
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
bd.sf <- geoboundaries("United Kingdom")
pre.sf = bd.sf
cell.x = 50
cell.y =50
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
fa = 30
ra <- raster:: aggregate(rr, fact = fa, fun = mean)
spol<-rasterToPolygons(ra, dissolve = F)
area.sf =st_as_sf(spol)
mesh = Mesh(bd.sf,max.edge,cut.off = 0.25,offset)
max.edge = c(0.7, 0.7)
offset = c(-0.05, -0.05)
prior.range = c(2, 0.01)
prior.sigma = c(10, 0.01)
proN = 27700
area.pre = area.pre(pre.sf,cell.x,cell.y,proN =27700)
setwd("~/Documents/Project 1/resources/sptialM")
source('mesh.R')
source('tarConstr.R')
area.pre = area.pre(pre.sf,cell.x,cell.y,proN =27700)
locin= st_join(p.sf,area.sf)
st_crs(area.sf) <- proN
locin= st_join(p.sf,area.sf)
View(locin)
locin= st_join(p.sf,area.sf,left = T)
locin= st_join(p.sf,area.sf,left = F)
View(locin)
locin= st_join(area.sf,p.sf,left = T)
View(locin)
View(p.sf)
locin= st_join(p.sf,area.sf,left = F)
p.sf
area.sf
point_data <- read.csv("~/Documents/Project 1/resources/data/2016PM2.5_avg copy.csv")
point_data = point_data[,c(1,2,3,4)]
point_data <- read.csv("~/Documents/Project 1/resources/data/2016PM2.5_avg copy.csv")
setwd("~/Documents/Project 1/data")
point_data <- read.csv("~/Documents/Project 1/data/2016PM2.5_avg copy.csv")
point_data <- read.csv("~/Documents/Project 1/data/2016PM2.5_avg.csv")
ggplot(data = p.sf$geometry)+geom_sf()
View(p.df)
# point data, load the data when wd is on data
p.df <- read.csv("2016PM2.5_avg.csv")
View(p.df)
colnames(p.df)<-c('py','px','value.p')
# point data, load the data when wd is on data
p.df <- read.csv("2016PM2.5_avg.csv")
p.df = p.df[,c(2,3,4)]
colnames(p.df)<-c('py','px','value.p')
p.sf = p.df %>%
st_as_sf(coords = c("px", "py"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
ggplot(data = p.sf$geometry)+geom_sf()
locin= st_join(point_sf,area,left = F)
locin= st_join(p.sf,area.sf,left = F)
# point data, load the data when wd is on data
p.df <- read.csv("2016PM2.5_avg.csv")
p.df = p.df[,c(2,3,4)]
p.df %>%
st_as_sf(coords = c("lon", "lat"), dim = "XY") %>% st_set_crs(proN) %>%
st_cast("MULTIPOINT")
library(openair)
library(tidyverse)
library(ggplot2)
library(plotly)
packages = c('raster','rgdal',
'rnaturalearth',
'viridis','rnaturalearthhires','sf','INLA','rgeoboundaries')
package.check = lapply(packages, FUN =function(x){
if(!require(x ,character.only = T))
install.packages(x)
if(!(x %in% ( .packages()  ) ) )
library(x ,character.only = T)})
point_data <- read.csv("~/Documents/Project 1/data/2016PM2.5_avg.csv")
View(point_data)
p.df = p.df[,c(2,3,4)]
setwd("~/Documents/Project 1/data")
# point data, load the data when wd is on data
p.df <- read.csv("2016PM2.5_avg.csv")
p.df = p.df[,c(2,3,4)]
View(p.df)
colnames(p.df)<-c('value.p','py','px')
p.sf = p.df %>%
st_as_sf(coords = c("px", "py"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
setwd("~/Documents/Project 1/data/area_2016_pm2.5")
# area data, load the data when wd is on data
str_name<-'gwr_pm25_2016.tif'
glo_pm = raster(str_name)
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
fa = 30
ra <- raster:: aggregate(rr, fact = fa, fun = mean)
packages = c('raster','rgdal',
'rnaturalearth',
'viridis','rnaturalearthhires','sf','INLA','rgeoboundaries','tidyverse')
package.check = lapply(packages, FUN =function(x){
if(!require(x ,character.only = T))
install.packages(x)
if(!(x %in% ( .packages()  ) ) )
library(x ,character.only = T)})
glo_pm = raster(str_name)
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
bd.sf <- geoboundaries("United Kingdom")
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
fa = 30
ra <- raster:: aggregate(rr, fact = fa, fun = mean)
spol<-rasterToPolygons(ra, dissolve = F)
area.sf =st_as_sf(spol)
st_crs(area.sf) <- proN
pre.sf = bd.sf
cutoff = 0.25
max.edge = c(0.7, 0.7)
offset = c(-0.05, -0.05)
prior.range = c(2, 0.01)
prior.sigma = c(10, 0.01)
proN = 27700
cell.x = 50
cell.y =50
setwd("~/Documents/Project 1/resources/sptialM")
st_crs(area.sf) <- proN
p.sf = p.df %>%
st_as_sf(coords = c("px", "py"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
View(p.df)
View(p.df)
locin= st_join(p.sf,area.sf,left = F)
View(locin)
