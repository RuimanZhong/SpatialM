d <- group_by(pennLC$data, county) %>% summarize(Y = sum(cases))
head(d)
d <- aggregate(
x = pennLC$data$cases,
by = list(county = pennLC$data$county),
FUN = sum
)
names(d) <- c("county", "Y")
pennLC$data <- pennLC$data[order(
pennLC$data$county,
pennLC$data$race,
pennLC$data$gender,
pennLC$data$age
), ]
E <- expected(
population = pennLC$data$population,
cases
ï¼‰
library(dplyr)
d <- group_by(pennLC$data, county) %>% summarize(Y = sum(cases))
head(d)
d <- aggregate(
x = pennLC$data$cases,
by = list(county = pennLC$data$county),
FUN = sum
)
names(d) <- c("county", "Y")
pennLC$data <- pennLC$data[order(
pennLC$data$county,
pennLC$data$race,
pennLC$data$gender,
pennLC$data$age
), ]
E <- expected(
population = pennLC$data$population,
cases = pennLC$data$cases, n.strata = 16
)
library(dplyr)
d <- group_by(pennLC$data, county) %>% summarize(Y = sum(cases))
head(d)
d <- aggregate(
x = pennLC$data$cases,
by = list(county = pennLC$data$county),
FUN = sum
)
names(d) <- c("county", "Y")
pennLC$data <- pennLC$data[order(
pennLC$data$county,
pennLC$data$race,
pennLC$data$gender,
pennLC$data$age
), ]
E <- expected(
population = pennLC$data$population,
cases = pennLC$data$cases, n.strata = 16
)
d$E <- E[match(d$county, unique(pennLC$data$county))]
head(d)
d$SIR <- d$Y / d$E
map <- merge(map, d)
mapsf <- st_as_sf(map)
ggplot(mapsf) + geom_sf(aes(fill = SIR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red"
) +
theme_bw()
formula <- Y ~
f(idareau, model = "besag", graph = g, scale.model = TRUE) +
f(idareav, model = "iid")
knitr::opts_chunk$set(echo = TRUE)
map$idarea <- 1:nrow(map@data)
prior <- list(
prec = list(
prior = "pc.prec",
param = c(0.5 / 0.31, 0.01)),
phi = list(
prior = "pc",
param = c(0.5, 2 / 3))
)
library(spdep)
nb <- poly2nb(map)
head(nb)
#install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
library(SpatialEpi)
library(spdep)
library(sf)
res <- inla(formula,
family = "poisson", data = map@data,
E = E, control.predictor = list(compute = TRUE)
)
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")
formula <- Y ~ f(idarea, model = "bym2", graph = g, hyper = prior)
res <- inla(formula,
family = "poisson", data = map@data,
E = E, control.predictor = list(compute = TRUE)
)
summary(res)
#summaries of the relative risks including the mean posterior and the lower and upper limits of 95% credible intervals of the relative risks
head(res$summary.fitted.values)
map$RR <- res$summary.fitted.values[, "mean"]
map$LL <- res$summary.fitted.values[, "0.025quant"]
map$UL <- res$summary.fitted.values[, "0.975quant"]
summary(map@data[, c("RR", "LL", "UL")])
map$RR <- res$summary.fitted.values[, "mean"]
map$LL <- res$summary.fitted.values[, "0.025quant"]
map$UL <- res$summary.fitted.values[, "0.975quant"]
summary(map@data[, c("RR", "LL", "UL")])
mapsf <- st_as_sf(map)
gRR <- ggplot(mapsf) + geom_sf(aes(fill = RR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
#install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
library(SpatialEpi)
library(spdep)
library(sf)
library(ggplot2)
map$RR <- res$summary.fitted.values[, "mean"]
map$LL <- res$summary.fitted.values[, "0.025quant"]
map$UL <- res$summary.fitted.values[, "0.975quant"]
summary(map@data[, c("RR", "LL", "UL")])
mapsf <- st_as_sf(map)
gRR <- ggplot(mapsf) + geom_sf(aes(fill = RR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
gRR <- ggplot(mapsf) + geom_sf(aes(fill = RR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
map$RR <- res$summary.fitted.values[, "mean"]
map$LL <- res$summary.fitted.values[, "0.025quant"]
map$UL <- res$summary.fitted.values[, "0.975quant"]
summary(map@data[, c("RR", "LL", "UL")])
mapsf <- st_as_sf(map)
gRR <- ggplot(mapsf) + geom_sf(aes(fill = RR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
gUL <- ggplot(mapsf) + geom_sf(aes(fill = UL)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
gLL <- ggplot(mapsf) + geom_sf(aes(fill = LL)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red",
limits = c(0.7, 1.5)
) +
theme_bw()
library(cowplot)
library(cowplot)
plot_grid(gRR, gLL, gUL, ncol = 1)
plot_grid(gRR, gLL, gUL, ncol = 1)
mapsf$re <- res$summary.random$idarea[1:67, "mean"]
ggplot(mapsf) + geom_sf(aes(fill = re)) +
scale_fill_gradient2(
midpoint = 0, low = "blue", mid = "white", high = "red"
) +
theme_bw()
knitr::opts_chunk$set(echo = TRUE)
library(geoR)
install.packages("geoR")
library(geoR)
library(geoR)
library(geoR)
install.packages("RandomFieldsUtils")
install.packages("RandomFieldsUtils")
knitr::opts_chunk$set(echo = TRUE)
#install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
library(SpatialEpi)
library(spdep)
library(sf)
library(ggplot2)
map <- pennLC$spatial.polygon
plot(map)
nb <- poly2nb(map)
head(nb) # output neighbors of each location
# set elements of spatial neighborhood matrices (choose 2, 44, 58)
d <- data.frame(county = names(map), neigh = rep(0, length(map)))
rownames(d) <- names(map)
map <- SpatialPolygonsDataFrame(map, d, match.ID = TRUE)
map$neigh[nb[[2]]] <- 1
map$neigh[nb[[44]]] <- 1
map$neigh[nb[[58]]] <- 1
#
coord <- coordinates(map)
map$long <- coord[, 1]
map$lat <- coord[, 2]
map$ID <- 1:dim(map@data)[1]
mapsf <- st_as_sf(map)
library(ggplot2)
ggplot(mapsf) + geom_sf(aes(fill = as.factor(neigh))) +
geom_text(aes(long, lat, label = ID), color = "white") +
theme_bw() + guides(fill = FALSE)
library(dplyr)
d <- group_by(pennLC$data, county) %>% summarize(Y = sum(cases))
head(d)
d <- aggregate(
x = pennLC$data$cases,
by = list(county = pennLC$data$county),
FUN = sum
)
names(d) <- c("county", "Y")
pennLC$data <- pennLC$data[order(
pennLC$data$county,
pennLC$data$race,
pennLC$data$gender,
pennLC$data$age
), ]
E <- expected(
population = pennLC$data$population,
cases = pennLC$data$cases, n.strata = 16
)
d$E <- E[match(d$county, unique(pennLC$data$county))]
head(d)
d$SIR <- d$Y / d$E
map <- merge(map, d)
mapsf <- st_as_sf(map)
ggplot(mapsf) + geom_sf(aes(fill = SIR)) +
scale_fill_gradient2(
midpoint = 1, low = "blue", mid = "white", high = "red"
) +
theme_bw()
formula <- Y ~
f(idareau, model = "besag", graph = g, scale.model = TRUE) +
f(idareav, model = "iid")
formula <- Y ~ f(idarea, model = "bym2", graph = g)
map$idarea <- 1:nrow(map@data)
prior <- list(
prec = list(
prior = "pc.prec",
param = c(0.5 / 0.31, 0.01)),
phi = list(
prior = "pc",
param = c(0.5, 2 / 3))
)
nb <- poly2nb(map)
head(nb)
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")
formula <- Y ~ f(idarea, model = "bym2", graph = g, hyper = prior)
res <- inla(formula,
family = "poisson", data = map@data,
E = E, control.predictor = list(compute = TRUE)
)
summary(res)
#summaries of the relative risks including the mean posterior and the lower and upper limits of 95% credible intervals of the relative risks
head(res$summary.fitted.values)
res$marginals.fitted.values
res$marginals.fitted.values
knitr::opts_chunk$set(echo = TRUE)
library(geoR)
library(geoR)
install.packages("RandomFieldsUtils")
# summary(res)
#summaries of the relative risks including the mean posterior and the lower and upper limits of 95% credible intervals of the relative risks
# head(res$summary.fitted.values)
res$marginals.fitted.values
View(res)
map$idarea <- 1:nrow(map@data)
prior <- list(
prec = list(
prior = "pc.prec",
param = c(0.5 / 0.31, 0.01)),
phi = list(
prior = "pc",
param = c(0.5, 2 / 3))
)
nb <- poly2nb(map)
head(nb)
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")
formula <- Y ~ f(idarea, model = "bym2", graph = g, hyper = prior)
res <- inla(formula,
family = "poisson", data = map@data,
E = E, control.predictor = list(compute = TRUE)
)
seq(from = 1, to = 100, by = 5)
rep(c(1,2,3,4), 3)
rep(c(1,2,3,4),each = 2)
seq(from = 1, length.out = 3)
data = seq(from = 1, to = 100, by = 5)
sample(data, 10)
sample(data, 10, replace = T)
options(digits=2)
sample(data, 10, replace = T)
x = 12.3545435
x
options(digits=2)
x
options(digits=8)
x = 12.3545435
x
y = c("a")
paste(x,y)
x = 12
paste(x,y)
paste0(x,y)
alphabet = paste0(LETTERS)
if (!require(openair)) {
install.packages("openair")
library(openair)
}
library(openair)
selected_data <- meta_data %>%
filter(variable == "PM2.5")
library(dplyr)
library(tidyverse)
meta_data <- importMeta(source = "aurn", all = TRUE)
head(meta_data, 3)
selected_data <- meta_data %>%
filter(variable == "PM2.5")
head(selected_data, 3)
View(selected_data)
gender = factor(c('female','male','unkown','female','male'),levels = c('male','female','unknown'))
library(dyplr)
library(dplyr)
library(tidyverse)
gneder2 = gender[gender ! = 'male']
gneder2 = gender[gender != 'male']
summary(gender2)
gender2 = gender[gender != 'male']
summary(gender2)
gender = factor(c('female','male','unknown','female','male'),levels = c('male','female','unknown'))
gender2 = gender[gender != 'male']
summary(gender2)
droplevels(gender2)
m2 <- matrix(1:12, nrow = 4, ncol = 3)
m2
rownames(m2) <- c("row1", "row2", "row3", "row4")
colnames(m2) <- c("col1", "col2", "col3")
#simplifying results in a named vector
m2[, 2]
which(is.na(df))
# Dataframe
df <- data.frame(col1 = 1:3,
col2 = c("this", "is", "text"),
col3 = c(TRUE, FALSE, TRUE),
col4 = c(2.5, 4.2, pi))
which(is.na(df))
which(is.na(df$col4))
# location of NA / how to find NA
x = as.vector(df$col4)
which(is.na(x))
# location of NA / how to find NA
colSums(is.na(df))
# location of NA / how to find NA
colSums(is.na(df))
# Dataframe
df <- data.frame(col1 = c(1:3, NA),
col2 = c("this", NA,"is", "text"),
col3 = c(TRUE, FALSE, TRUE, TRUE),
col4 = c(2.5, 4.2, 3.2, NA),
stringsAsFactors = FALSE)
# location of NA / how to find NA
colSums(is.na(df))
5/0
0/0
setwd("~/Documents/Project 1/resources/codes/sptialM")
source('mesh.R')
source('dwscaler.R')
source('tarConstr.R')
setwd("~/Documents/Project 1/resources/codes/sptialM")
setwd("~/Documents/Project 1/resources/codes/sptialM")
cannot change working directory
getwd()
setwd("~/Documents/Project 1/resources/codes")
setwd("~/Documents/Project 1/resources/sptialM")
source('mesh.R')
source('dwscaler.R')
source('tarConstr.R')
source('geosp.R')
source('meld.R')
# point data
p.df <- read.csv("~/data/2016PM2.5_avg.csv")
setwd("~/Documents/Project 1/resources/sptialM/data")
# point data, load the data when wd is on data
p.df <- read.csv("2016PM2.5_avg.csv")
p.lon =p.df$longitude
p.lat = p.df$latitude
p.value = p.df$mean
bd.sf <- geoboundaries("United Kingdom")
cutoff = 0.25
max.edge = c(0.7, 0.7)
offset = c(-0.05, -0.05)
prior.range = c(2, 0.01)
prior.sigma = c(10, 0.01)
proN = 27700
pre.sf = bd.sf
cell.x = 50
cell.y =50
packages = c('raster','rgdal',
'rnaturalearth',
'viridis','rnaturalearthhires','sf','INLA','rgeoboundaries','tidyverse')
package.check = lapply(packages, FUN =function(x){
if(!require(x ,character.only = T))
install.packages(x)
if(!(x %in% ( .packages()  ) ) )
library(x ,character.only = T)})
bd.sf <- geoboundaries("United Kingdom")
setwd("~/Documents/Project 1/resources/sptialM/data/area_2016_pm2.5")
# area data, load the data when wd is on data
str_name<-'gwr_pm25_2016.tif'
glo_pm = raster(str_name)
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
fa = 30
ra <- raster:: aggregate(rr, fact = fa, fun = mean)
spol<-rasterToPolygons(ra, dissolve = F)
area.sf =st_as_sf(spol)
mesh = Mesh(bd.sf,max.edge,cut.off = 0.25,offset)
plot(mesh)
area.pre = area.pre(pre.sf,cell.x,cell.y,proN =27700)
pre.sf = bd.sf
area.pre = area.pre(pre.sf,cell.x,cell.y,proN =27700)
a = dwscaler.spde (mesh,area.pre,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),
p.lon,p.lat,p.value,area.sf,proN = 27700)
form = y ~ 0 + b0 + f(s, model = spde)
b=geosp(form,mesh,p.lon,p.lat,p.value,area.pre,alpha = 2)
source('geosp.R')
setwd("~/Documents/Project 1/resources/sptialM")
source('geosp.R')
source('meld.R')
form = y ~ 0 + b0 + f(s, model = spde)
b=geosp(form,mesh,p.lon,p.lat,p.value,area.pre,prior.range = c(2, 0.01),prior.sigma = c(10, 0.01))
c = meld(form,mesh,area.pre,
p.lon,p.lat,p.value,area.sf,prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),proN)
source('meld.R')
View(meld)
c = meld(form,mesh,area.pre,
p.lon,p.lat,p.value,area.sf,prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),proN = 27700)
area.sf =st_as_sf(spol)
c = meld(form,mesh,area.pre,
p.lon,p.lat,p.value,area.sf,prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),proN = 27700)
c = meld(mesh,area.pre,
p.lon,p.lat,p.value,area.sf,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),proN = 27700)
Apred = inla.spde.make.A(mesh = mesh, loc = as.matrix (st_coordinates(area.pre[,1])))
source('meld.R')
c = meld(mesh,area.pre,
p.lon,p.lat,p.value,area.sf,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),proN = 27700)
proN = 27700
st_crs(area.sf) <- proN
p.df = data.frame(lon = p.lon,lat = p.lat,value = p.value )
colnames(area.sf) = c("value.a", "geometry")
attributes(area.sf)
locin_pred = st_join(area.pre,area.sf,left = F)
# Projection Matrix
meshcoo = data.frame(long = mesh$loc[,1],lat = mesh$loc[,2] )
meshin = meshcoo %>%
st_as_sf(coords = c("long", "lat"), dim = "XY") %>%
st_set_crs(27700) %>%
st_cast("MULTIPOINT")
# find points in mesh n area.sf
locin= st_join(meshin,area.sf,left = F)
block <- rep(0, nrow(locin))
for(i in 1:nrow(area.sf)){
block[as.vector(which(!is.na(st_join(locin, area.sf[i,],left = T)$value.a.y)))] <- i
}
for(i in 1:nrow(area.sf)){
block[as.vector(which(!is.na(st_join(locin, area.sf[i,],left = T)$value.a.y)))] <- i
}
block
Ap = inla.spde.make.A(mesh, cbind(p.lon,p.lat))
Aa <- inla.spde.make.A(mesh=mesh,
loc=as.matrix(st_coordinates(locin[,1]))[,c(1,2)],
block=block,
block.rescale="sum")
Apred = inla.spde.make.A(mesh = mesh, loc = as.matrix (st_coordinates(area.pre[,1])))
#construct SPDE
spde = inla.spde2.pcmatern(
mesh = mesh,
prior.range = prior.range,
prior.sigma = prior.sigma)
stk.full = stack.full.meld(A,Aa,Apred,p.df,area.sf,locin_pred,spde)
#******************Construct Stack*********************************
stack.full.meld = function(Ap,Aa,Apred,p.df,area.sf,locin_pred,spde){
ya = area.sf$value.a
stk.p <- inla.stack(tag='point',
data=list(y=p.df$value),
A=list(Ap, 1),effects=list(s=1:spde$n.spde, data.frame(b0 =rep(1, length(p.df$value)))))
stk.a <- inla.stack(tag= 'areal',data=list(y=ya),
A=list(Aa, 1),effects=list(s=1:spde$n.spde,
data.frame(b0 =rep(1, length(ya)))))
stk.pred <- inla.stack(tag= 'pred',
data=list(y=NA),
A=list(Apred, 1),
effects=list(s=1:spde$n.spde,
data.frame(b0 =rep(1, nrow(locin_pred)))))
inla.stack(stk.p, stk.a, stk.pred)
}
stk.full = stack.full.meld(Ap,Aa,Apred,p.df,area.sf,locin_pred,spde)
source('meld.R')
c = meld(mesh,area.pre,
p.lon,p.lat,p.value,area.sf,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),proN = 27700)
View(c)
