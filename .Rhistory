m2 = cbind(c(0, 1, 1, 0), c(0, 0, 1, 0))
pol = st_sfc(st_polygon(list(m1)), st_polygon(list(m2)))
set.seed(1985)
d = data.frame(matrix(runif(15), ncol = 3))
p = st_as_sf(x = d, coords = 1:2)
plot(pol)
plot(p, add = TRUE)
View(p)
(p_ag1 = aggregate(p, pol, mean))
View(p_ag1)
plot(pol)
View(pol)
pol
View(area.sf)
View(pol)
group = area.sf$geometry
a = dwscaler.spde (mesh, area.pre,
prior.range = c(2, 0.01),
prior.sigma = c(10, 0.01),
p.sf, area.sf)
View(a)
View(a)
p = a[[1]][["pred_mean"]]
View(a)
p = a[[1]]
View(p)
source('mesh.R')
source('check.r')
source('dwscalerv2.R')
source('tarConstr.R')
source('meld_v3.R')
a = dwscaler.spde (mesh, area.pre,
prior.range = c(2, 0.01),
prior.sigma = c(10, 0.01),
p.sf, area.sf)
View(a)
p.sf = a %>%
st_as_sf(coords = c("px", "py"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
View(p.sf)
p_ag1 = aggregate(p.sf, group, mean)
View(p_ag1)
ggplot(p.sf)+geom_sf()
source('mesh.R')
source('check.r')
source('dwscalerv2.R')
source('tarConstr.R')
source('meld_v3.R')
source('check.r')
source('areal.R')
source('mesh.R')
source('geosp.R')
packages = c('raster','rgdal',
'rnaturalearth',
'viridis','rnaturalearthhires','sf','INLA','rgeoboundaries','tidyverse')
package.check = lapply(packages, FUN =function(x){
if(!require(x ,character.only = T))
install.packages(x)
if(!(x %in% ( .packages()  ) ) )
library(x ,character.only = T)})
setwd("~/Documents/Project 1/data")
str_name<-'area_2016_pm2.5/gwr_pm25_2016.tif'
glo_pm = raster(str_name)
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
fa = 30
ra <- raster:: aggregate(rr, fact = fa, fun = mean)
spol<-rasterToPolygons(ra, dissolve = F)
area.sf = st_as_sf(spol)
st_transform(area.sf, proN)
colnames(area.sf) = c('value.a','geometry')
mesh = Mesh(area.sf,cut.off = 0.1)
bd.sf <- geoboundaries("United Kingdom")
mesh = Mesh(area.sf,cut.off = 0.1)
check_mesh(area.sf)
area.sf$centroids = st_transform(area.sf, proN) %>%
st_centroid()
proN = 4326
cell.x = 50
cell.y =50
area.sf$centroids = st_transform(area.sf, proN) %>%
st_centroid()
bd = st_union(area.sf)
bd.ss  = as(bd,Class = 'Spatial')
max.edge = max(attributes(st_geometry(area.sf))$bbox[3] -attributes(st_geometry(area.sf))$bbox[1],
attributes(st_geometry(area.sf))$bbox[4] -attributes(st_geometry(area.sf))$bbox[2])/10
inla.mesh.2d(
boundary = bd.ss,
max.edge = max.edge, cutoff = cutoff,
offset = offset)
)
inla.mesh.2d(
boundary = bd.ss,
max.edge = max.edge, cutoff = cutoff,
offset = offset)
mesh = Mesh(area.sf,cut.off = 0.1)
source('check.r')
source('areal.R')
source('mesh.R')
source('geosp.R')
setwd("~/Documents/Project 1/resources/sptialM")
source('check.r')
source('areal.R')
source('mesh.R')
source('geosp.R')
mesh = Mesh(area.sf,cut.off = 0.1)
plot(mesh)
offset = c(-0.05, -0.05)
mesh = inla.mesh.2d(
boundary = bd.ss,
max.edge = max.edge, cutoff = cutoff,
offset = offset)
plot(mesh)
packages = c('raster','rgdal',
'rnaturalearth',
'viridis','rnaturalearthhires','sf','INLA','rgeoboundaries','tidyverse')
package.check = lapply(packages, FUN =function(x){
if(!require(x ,character.only = T))
install.packages(x)
if(!(x %in% ( .packages()  ) ) )
library(x ,character.only = T)})
setwd("~/Documents/Project 1/resources/sptialM")
source('mesh.R')
source('check.r')
source('dwscalerv2.R')
source('tarConstr.R')
source('meld_v3.R')
pre.sf = bd.sf
cutoff = 0.25
max.edge = c(0.7, 0.7)
offset = c(-0.05, -0.05)
prior.range = c(2, 0.01)
prior.sigma = c(10, 0.01)
proN = 4326
cell.x = 50
cell.y =50
# point data, load the data when wd is on data
setwd("~/Documents/Project 1/data")
st_transform(bd.sf, proN)
p.df = read.csv("2016PM2.5_avg.csv")
p.df = p.df[,c(2,3,4)]
colnames(p.df)<-c('value.p','py','px')
p.sf = p.df %>%
st_as_sf(coords = c("px", "py"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
str_name<-'area_2016_pm2.5/gwr_pm25_2016.tif'
glo_pm = raster(str_name)
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
fa = 30
ra <- raster:: aggregate(rr, fact = fa, fun = mean)
spol<-rasterToPolygons(ra, dissolve = F)
area.sf = st_as_sf(spol)
st_transform(area.sf, proN)
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
fa = 30
ra <- raster:: aggregate(rr, fact = fa, fun = mean)
spol<-rasterToPolygons(ra, dissolve = F)
area.sf = st_as_sf(spol)
st_transform(area.sf, proN)
colnames(area.sf) = c('value.a','geometry')
ggplot(data = p.sf$geometry) + geom_sf()
mesh = Mesh(bd.sf, max.edge, cut.off = 0.1, offset)
mesh = Mesh(bd.sf, max.edge, cut.off = 0.1)
plot(mesh)
mesh = Mesh(area.sf, max.edge, cut.off = 0.1)
plot(mesh)
mesh = Mesh(area.sf,offset =c(-0.05,-0.05), cut.off = 0.1)
plot(mesh)
check_mesh(area.sf)
area.sf$centroids = st_transform(area.sf, proN) %>%
st_centroid()
loc.sf = as.matrix(st_coordinates(area.sf$centroids[,1]))[,c(1,2)]
bd = st_union(area.sf)
bd.ss  = as(bd,Class = 'Spatial')
max.edge = max(attributes(st_geometry(area.sf))$bbox[3] -attributes(st_geometry(area.sf))$bbox[1],
attributes(st_geometry(area.sf))$bbox[4] -attributes(st_geometry(area.sf))$bbox[2])/10
mesh = inla.mesh.2d(
boundary = bd.ss,
max.edge = max.edge, cutoff = cutoff,
offset = offset)
)
mesh = inla.mesh.2d(
boundary = bd.ss,
max.edge = max.edge, cutoff = cutoff,
offset = offset)
plot(mesh)
mesh = inla.mesh.2d(
loc = loc.sf,
boundary = bd.ss,
max.edge = max.edge, cutoff = cutoff,
offset = offset)
plot(mesh)
#  require a continuous surface
bd = st_union(area.sf)
area.pre = target(bd.sf = bd, cell.x =cell.x,cell.y =  cell.y, proN = proN)
View(bd)
View(bd)
bd
bd.ss  = as(bd,Class = 'Spatial')
bd.ss
area.sf
bd = st_union(area.sf)
View(bd)
plot(bd)
class(bd)
bd.sf = st_union(area.sf)
area.sf = st_transform(bd.sf, proN)
View(area.sf)
bb = unname(attributes(st_geometry(area.sf))$bbox)
x = seq(bb[1] - 1, bb[3] + 1, length.out = cell.x)
y = seq(bb[2] - 1, bb[4] + 1, length.out = cell.y)
coop = expand.grid(x, y)
coop_sf = sf::st_as_sf(coop, coords = c('Var1','Var2'), crs = proN)
area.sf = area.sf%>%
st_set_crs(proN)
plot(area.sf)
area.sf
plot(coop_sf)
coop_sf %>%
st_join(pre.sf, left = FALSE)
plot(coop_sf)
pre.sf = coop_sf %>%
st_join(pre.sf, left = FALSE)
plot(pre.sf)
pre.sf = coop_sf %>%
st_join(area.sf, left = FALSE)
coop_sf = sf::st_as_sf(coop, coords = c('Var1','Var2'), crs = proN)
st_as_sf(bd.sf)
bd.sf = st_as_sf(bd.sf)
View(bd.sf)
bd.sf = st_union(area.sf)
bd.sf = st_as_sf(bd.sf)
plot(bd.sf)
class(bd.sf)
bd.sf
bd.sf = st_as_sf(st_union(area.sf))
area.sf = st_transform(bd.sf, proN)
bb = unname(attributes(st_geometry(area.sf))$bbox)
x = seq(bb[1] - 1, bb[3] + 1, length.out = cell.x)
y = seq(bb[2] - 1, bb[4] + 1, length.out = cell.y)
coop = expand.grid(x, y)
plot(coop)
coop_sf = sf::st_as_sf(coop, coords = c('Var1','Var2'), crs = proN)
pre.sf = coop_sf %>%
st_join(area.sf, left = FALSE)
plot(pre.sf)
setwd("~/Documents/Project 1/resources/sptialM")
source('mesh.R')
source('check.r')
source('dwscalerv2.R')
source('tarConstr.R')
area.pre = target(pre.sf = area.sf, cell.x =cell.x,cell.y =  cell.y, proN = proN)
pre.sf = area.sf
bd.sf = NULL
if(is.null(pre.sf) == F && is.null(bd.sf == T)) {
bd.sf = st_as_sf(st_union(pre.sf))
}
is.null(pre.sf) == F
source('tarConstr.R')
area.pre = target(pre.sf = area.sf, cell.x =cell.x,cell.y =  cell.y, proN = proN)
if(is.null(pre.sf) == F && is.null(bd.sf) == T) {
bd.sf = st_as_sf(st_union(pre.sf))
}
View(bd.sf)
plot(bd.sf)
bd.sf = st_transform(bd.sf, proN)
bb = unname(attributes(st_geometry(bd.sf))$bbox)
x = seq(bb[1] - 1, bb[3] + 1, length.out = cell.x)
y = seq(bb[2] - 1, bb[4] + 1, length.out = cell.y)
coop = expand.grid(x, y)
coop_sf = sf::st_as_sf(coop, coords = c('Var1','Var2'), crs = proN)
target = coop_sf %>%
st_join(target, left = FALSE)
coop_sf = sf::st_as_sf(coop, coords = c('Var1','Var2'), crs = proN)
View(coop_sf)
target = coop_sf %>%
st_join(bd.sf, left = FALSE)
plot(target)+geom_sf()
area.pre = target(pre.sf = area.sf, cell.x =cell.x,cell.y =  cell.y, proN = proN)
source('tarConstr.R')
area.pre = target(pre.sf = area.sf, cell.x =cell.x,cell.y =  cell.y, proN = proN)
View(area.pre)
setwd("~/Documents/Project 1/resources/sptialM")
source('predict.R')
source('prediction.R')
a = dwscaler.spde (mesh = mesh, target = area.pre, areaPre.sf = NULL,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01),
p.sf = p.sf, area.sf = area.sf)
source('dwscalerv2.R')
a = dwscaler.spde (mesh = mesh, target = area.pre, areaPre.sf = NULL,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01),
p.sf = p.sf, area.sf = area.sf)
colnames(area.sf) = c('value.a','geometry')
View(area.sf)
glo_pm = raster(str_name)
rr <- mask(crop(glo_pm, bd.sf), bd.sf)
fa = 30
ra <- raster:: aggregate(rr, fact = fa, fun = mean)
spol<-rasterToPolygons(ra, dissolve = F)
area.sf = st_as_sf(spol)
st_transform(area.sf, proN)
colnames(area.sf) = c('value.a','geometry')
area.pre = target(pre.sf = area.sf, cell.x =cell.x,cell.y =  cell.y, proN = proN)
View(area.pre)
a = dwscaler.spde (mesh = mesh, target = area.pre, areaPre.sf = NULL,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01),
p.sf = p.sf, area.sf = area.sf)
source('dwscalerv2.R')
a = dwscaler.spde (mesh = mesh, target = area.pre, areaPre.sf = NULL,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01),
p.sf = p.sf, area.sf = area.sf)
View(a)
formula = y ~ 0 + b0 + f(s, model = spde)
b_1 = meld(formula =formula, mesh = mesh,
p.sf = p.sf, target = area.pre,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01))
source('meld_v3.R')
source('mesh.R')
source('check.r')
source('dwscalerv2.R')
source('tarConstr.R')
source('meld_v3.R')
source('prediction.R')
b_1 = meld(formula =formula, mesh = mesh,
p.sf = p.sf, target = area.pre,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01))
b_1 = meld(formula =formula, mesh = mesh,
p.sf = p.sf, target = area.pre,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01))
source('meld_v3.R')
b_1 = meld(formula =formula, mesh = mesh,
p.sf = p.sf, target = area.pre,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01))
View(b_1)
b_2 = meld(formula =formula,
mesh = mesh, p.sf = NULL,
area.sf = area.sf,
target = area.pre,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01))
c = meld(formula =formula,
mesh = mesh, target = area.pre,
p.sf = p.sf,area.sf = area.sf,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),proN = proN)
locin_pred = st_join(target, area.sf, left = F)
locin_pred = st_join(target, area.sf, left = F)
target = area.pre
locin_pred = st_join(target, area.sf, left = F)
# Projection Matrix
meshcoo = data.frame(long = mesh$loc[,1], lat = mesh$loc[,2])
meshin = meshcoo %>%
st_as_sf(coords = c("long", "lat"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
locin= st_join(meshin, area.sf, left = F)
block <- rep(0, nrow(locin))
for(i in 1:nrow(area.sf)) {
block[as.vector(which(!is.na(st_join(locin, area.sf[i,], left = T)$value.a.y)))] <- i
}
Ap = inla.spde.make.A(mesh, as.matrix(st_coordinates(p.sf[,1]))[,c(1,2)])
Aa <- inla.spde.make.A(mesh=mesh,
loc=as.matrix(st_coordinates(locin[,1]))[,c(1,2)],
block=block,
block.rescale="sum")
Apred = inla.spde.make.A(mesh = mesh, loc = as.matrix (st_coordinates(target[,1])))
stk.full = stack.full.meld(Ap, Aa, Apred, p.df, area.sf, locin_pred, spde)
stk.p <- inla.stack(tag='point',
data=list(y=p.sf$value.p),
A=list(Ap, 1),
effects=list(s=1:spde$n.spde,
data.frame(b0 =rep(1, length(p.sf$value.p))
)
)
)
spde = inla.spde2.pcmatern(
mesh = mesh,
prior.range = prior.range,
prior.sigma = prior.sigma)
Ap = inla.spde.make.A(mesh, as.matrix(st_coordinates(p.sf[,1]))[,c(1,2)])
Aa <- inla.spde.make.A(mesh=mesh,
loc=as.matrix(st_coordinates(locin[,1]))[,c(1,2)],
block=block,
block.rescale="sum")
Apred = inla.spde.make.A(mesh = mesh, loc = as.matrix (st_coordinates(target[,1])))
dim(Ap)
dim(Aa)
dim(Apred)
spde$n.spde
stk.p <- inla.stack(tag='point',
data=list(y=p.sf$value.p),
A=list(Ap, 1),
effects=list(s=1:spde$n.spde,
data.frame(b0 =rep(1, length(p.sf$value.p))
)
)
)
stk.full = stack.full.meld(Ap, Aa, Apred, p.df, area.sf, locin_pred, spde)
b_2 = meld(formula =formula,
mesh = mesh, p.sf = NULL,
area.sf = area.sf,
target = area.pre,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01))
c = meld(formula =formula,
mesh = mesh, target = area.pre,
p.sf = p.sf,area.sf = area.sf,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01),proN = proN)
stk.full = stack.full.meld(Ap, Aa, Apred, p.df, area.sf, locin_pred, spde)
stk.full = stack.full.meld(Ap, Aa, Apred, p.df, area.sf, locin_pred, spde)
#estimation and prediction
res <- inla(formula,
data = inla.stack.data(stk.full),
control.predictor = list(
compute = TRUE,
A = inla.stack.A(stk.full)
))
return(pred(res,stk.full,target,areaPre.sf,proN))
c = meld(formula =formula,
mesh = mesh, target = area.pre,
p.sf = p.sf,area.sf = area.sf,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01), proN = proN)
#estimation and prediction
res <- inla(formula,
data = inla.stack.data(stk.full),
control.predictor = list(
compute = TRUE,
A = inla.stack.A(stk.full)
))
stk.full = stack.full.meld(Ap, Aa, Apred, p.df, area.sf, locin_pred, spde)
target = area.pre
locin_pred = st_join(target, area.sf, left = F)
# Projection Matrix
meshcoo = data.frame(long = mesh$loc[,1], lat = mesh$loc[,2])
meshin = meshcoo %>%
st_as_sf(coords = c("long", "lat"), dim = "XY") %>%
st_set_crs(proN) %>%
st_cast("MULTIPOINT")
locin= st_join(meshin, area.sf, left = F)
block <- rep(0, nrow(locin))
for(i in 1:nrow(area.sf)) {
block[as.vector(which(!is.na(st_join(locin, area.sf[i,], left = T)$value.a.y)))] <- i
}
Ap = inla.spde.make.A(mesh, as.matrix(st_coordinates(p.sf[,1]))[,c(1,2)])
Aa <- inla.spde.make.A(mesh=mesh,
loc=as.matrix(st_coordinates(locin[,1]))[,c(1,2)],
block=block,
block.rescale="sum")
Apred = inla.spde.make.A(mesh = mesh, loc = as.matrix (st_coordinates(target[,1])))
stk.full = stack.full.meld(Ap, Aa, Apred, p.df, area.sf, locin_pred, spde)
prediction = melding(mesh = mesh, p.sf = p.sf, area.sf = area.sf,
target = target, areaPre.sf = areaPre.sf,
spde = spde, proN = proN)
prediction = melding(formula = formula, mesh = mesh, p.sf = p.sf, area.sf = area.sf,
target = target, areaPre.sf = areaPre.sf,
spde = spde, proN = proN)
c = meld(formula =formula,
mesh = mesh, target = area.pre,
p.sf = p.sf,area.sf = area.sf,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01), proN = proN)
source('meld_v3.R')
c = meld(formula =formula,
mesh = mesh, target = area.pre,
p.sf = p.sf,area.sf = area.sf,
prior.range = c(2, 0.01),prior.sigma = c(10, 0.01), proN = proN)
View(c)
fa = 100
ra <- raster:: aggregate(rr, fact = fa, fun = mean)
spol<-rasterToPolygons(ra, dissolve = F)
block = st_as_sf(spol)
st_transform(block, proN)
colnames(area.sf) = c('value.a','geometry')
colnames(block) = c('value.a','geometry')
a_blcok = dwscaler.spde (mesh = mesh, target = area.pre, areaPre.sf = block,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01),
p.sf = p.sf, area.sf = area.sf)
View(a_blcok)
source('prediction.R')
a_blcok = dwscaler.spde (mesh = mesh, target = area.pre, areaPre.sf = block,
prior.range = c(2, 0.01), prior.sigma = c(10, 0.01),
p.sf = p.sf, area.sf = area.sf)
View(a_blcok)
plot(block)
pre.group = aggregate(a, group, mean)
View(pre.group)
group = blcok$geometry
group = block$geometry
plot(a)
pre.group = aggregate(a, group, mean)
plot(pre.group)
st_transform(block, proN)
st_join(a, group, left = T)
st_join(a, block, left = T)
m = st_join(a, block, left = T)
View(m)
m = st_join(a, block)
View(m)
m = st_join(a, block)
m = st_join(a, block,left = T)
View(m)
m = st_join(a, block,left = F)
m = st_join(a, block,left = F)
n =  st_join(block, a,left = F)
View(n)
View(m)
plot(group)
coo = as.matrix(st_coordinates(a[,1]))
points(coo, col = "red")
points(coo[5], col = "blue")
plot(group)
points(coo[5], col = "blue")
points(coo[5,], col = "blue")
points(coo[1:5,], col = "blue")
points(coo, col = "red")
