if(unif == F) {p1 = pimsample(pnum,r, crsproj)}
a1 = areasample(anum, r, crsproj)
true <- raster::extract(r, as.matrix(st_coordinates(dppoint)))
mesh = fnCreateMesh(p1, boundaryregion)
meld = fnPredictMelding(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
down = fnPredictDown(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
ensemble = fnPredictEnsemble(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
m1 = Metrics::mse(true,meld[[1]]$pred_mean)
m2 = Metrics::mse(true,down[[1]]$pred_mean)
m3 = Metrics::mse(true,ensemble)
M1 = c(M1,m1)
M2 = c(M2,m2)
M3 = c(M3,m3)
}
return(list(M1, M2, M3))
}
install.packages("doParallel")
library(doParallel)
mclapply(c(100, 1000), mysimulate, scale = 0.05,nu = 2, var = 1,mean = 10, anum = 2, N = 1)
?RandomFieldsUtils::RFoptions
RFoptions(cores = 4)
RFoptions(cores = 2)
meld = fnPredictMelding(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
down = fnPredictDown(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
ensemble = fnPredictEnsemble(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
m1 = Metrics::mse(true,meld[[1]]$pred_mean)
m2 = Metrics::mse(true,down[[1]]$pred_mean)
m3 = Metrics::mse(true,ensemble)
# Logical values indicating what datasets I have
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
dt = sort(sample(nrow(de1), nrow(de1)*.8))
de_train <- de1[dt,]
de_test <- de1[-dt,]
base_melding <- fnPredictMelding(depoint = de_train, de2, dppoint = de_test, dparea = NULL, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
base_down <- fnPredictDown(depoint = de_train, de2, dppoint = de_test, dparea = NULL, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
data <- st_join(base_melding,base_down)
newdata <- st_join(final_melding,final_down)
regressControl  <- trainControl(method="repeatedcv",
number = 3,
repeats = 3
)
stack_regression_const <- train(
value ~ pred_mean.x + pred_mean.y, data = data, method = "lm",
tuneGrid  = expand.grid(intercept = FALSE),
trControl = regressControl,
tuneLength = 10
)
final_pred = predict(stack_regression_const, newdata = newdata)
ensemble = final_pred
m3 = Metrics::mse(true,ensemble)
ensemble = fnPredictEnsemble(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
m3 = Metrics::mse(true,ensemble)
dw1 = p1
de1 =  p1
ensemble = fnPredictEnsemble(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
#source('CV.R')
fnPredictEnsemble = function(depoint = NULL, dearea = NULL, dppoint = NULL, dparea = NULL, boundaryregion,
mesh = NULL, priorspdesigma = NULL, priorspderange = NULL, SCV = F ){
# Use 1 for points and 2 for areas
# datasets estimation
de1 <- depoint
de2 <- dearea
# datasets prediction
dp1 <- dppoint
dp2 <- dparea
prior1 <- priorspdesigma
prior2 <- priorspderange
mesh <- mesh
set.seed(123)
# Logical values indicating what datasets I have
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
dt = sort(sample(nrow(de1), nrow(de1)*.8))
de_train <- de1[dt,]
de_test <- de1[-dt,]
base_melding <- fnPredictMelding(depoint = de_train, de2, dppoint = de_test, dparea = NULL, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
base_down <- fnPredictDown(depoint = de_train, de2, dppoint = de_test, dparea = NULL, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
data <- st_join(base_melding,base_down)
final_melding <- fnPredictMelding(depoint = de1, de2, dppoint = dp1, dparea = dp2, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
final_down <- fnPredictDown(depoint = de1, de2, dppoint = dp1, dparea = dp2, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
newdata <- st_join(final_melding,final_down)
#standard CV
#----
if(SCV == F) {
regressControl  <- trainControl(method="repeatedcv",
number = 3,
repeats = 3
)
stack_regression_const <- train(
value ~ pred_mean.x + pred_mean.y, data = data, method = "lm",
tuneGrid  = expand.grid(intercept = FALSE),
trControl = regressControl,
tuneLength = 10
)
final_pred = predict(stack_regression_const, newdata = newdata)
}
#----
# spatial coefficients
#----
# Specify formula
if(SCV == T){
# mesh_ensem <- fnCreateMesh(data, boundaryregion)
#
# formula <- y ~ 0  + X1 + X2 + f(s, model = spde) + f(s1, model = spde)
#
# if(!is.null(prior1) & !is.null(prior2)){
#   fnCheckPrior(prior1, prior2)
#   spde <- inla.spde2.pcmatern(mesh = mesh_ensem, prior.range = prior2, prior.sigma = prior1)
# }else{
#   spde <- inla.spde2.matern(mesh = mesh_ensem, alpha = 2, constr = T)
# }
#
# indexs <- inla.spde.make.index("s", spde$n.spde)
# indexs1 <- inla.spde.make.index("s1", spde$n.spde)
#
# Ae <- inla.spde.make.A(mesh_ensem, loc = as.matrix(st_coordinates(data$geometry))[, c(1, 2)])
# Ap <- inla.spde.make.A(mesh = mesh_ensem, loc = as.matrix(st_coordinates(dp1$geometry)))
#
# stk.e <- inla.stack(tag = "est", data = list(y = data$value),
#                     A = list( Ae * data$pred_mean.x, Ae * data$pred_mean.y, Ae),
#                     effects = list(data.frame(X1 = data$pred_mean.x, X2 = data$pred_mean.y), s = indexs$s, s1 = indexs1$s1))
# stk.p <- inla.stack(tag = "pred2", data = list(y = NA),
#                     A = list( Ap * data$pred_mean.x, Ap * data$pred_mean.y, Ap ),
#                     effects = list(data.frame( X1 = data$pred_mean.x, X2 = data$pred_mean.y), s = indexs$s, s1 = indexs1$s1))
# # Call inla()
# res <- inla(formula, data = inla.stack.data(stk.full), control.predictor = list(compute = TRUE, A = inla.stack.A(stk.full)))
}
return(final_pred)
}
ensemble = fnPredictEnsemble(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
set.seed(123)
# Logical values indicating what datasets I have
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
dt = sort(sample(nrow(de1), nrow(de1)*.8))
de_train <- de1[dt,]
de_test <- de1[-dt,]
base_melding <- fnPredictMelding(depoint = de_train, de2, dppoint = de_test, dparea = NULL, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
base_down <- fnPredictDown(depoint = de_train, de2, dppoint = de_test, dparea = NULL, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
data <- st_join(base_melding,base_down)
regressControl  <- trainControl(method="repeatedcv",
number = 3,
repeats = 3
)
stack_regression_const <- train(
value ~ pred_mean.x + pred_mean.y, data = data, method = "lm",
tuneGrid  = expand.grid(intercept = FALSE),
trControl = regressControl,
tuneLength = 10
)
final_pred = predict(stack_regression_const, newdata = newdata)
ensemble = final_pred
m3 = Metrics::mse(true,ensemble)
regressControl  <- trainControl(method="repeatedcv",
number = 3,
repeats = 3
)
stack_regression_const <- train(
value ~ pred_mean.x + pred_mean.y, data = data, method = "lm",
tuneGrid  = expand.grid(intercept = FALSE),
trControl = regressControl,
tuneLength = 10
)
final_pred = predict(stack_regression_const, newdata = newdata)
regressControl  <- trainControl(method="repeatedcv",
number = 4,
repeats = 5
)
stack_regression_const <- train(
value ~ pred_mean.x + pred_mean.y, data = data, method = "lm",
tuneGrid  = expand.grid(intercept = FALSE),
trControl = regressControl,
tuneLength = 10
)
final_pred = predict(stack_regression_const, newdata = newdata)
regressControl  <- trainControl(method="repeatedcv",
number = 4,
repeats = 5
)
stack_regression_const <- train(
value ~ pred_mean.x + pred_mean.y, data = data, method = "lm",
tuneGrid  = expand.grid(intercept = FALSE),
trControl = regressControl,
tuneLength = 10
)
final_pred = predict(stack_regression_const, newdata = newdata)
regressControl  <- trainControl(method="repeatedcv",
number = 3,
repeats = 3
)
stack_regression_const <- train(
value ~ pred_mean.x + pred_mean.y, data = data, method = "lm",
tuneGrid  = expand.grid(intercept = FALSE),
trControl = regressControl,
tuneLength = 10
)
final_pred = predict(stack_regression_const, newdata = newdata)
ensemble = fnPredictEnsemble(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
#source('CV.R')
fnPredictEnsemble = function(depoint = NULL, dearea = NULL, dppoint = NULL, dparea = NULL, boundaryregion,
mesh = NULL, priorspdesigma = NULL, priorspderange = NULL, SCV = F ){
# Use 1 for points and 2 for areas
# datasets estimation
de1 <- depoint
de2 <- dearea
# datasets prediction
dp1 <- dppoint
dp2 <- dparea
prior1 <- priorspdesigma
prior2 <- priorspderange
mesh <- mesh
set.seed(123)
# Logical values indicating what datasets I have
dp1ToF <- !is.null(dp1)
dp2ToF <- !is.null(dp2)
dt = sort(sample(nrow(de1), nrow(de1)*.8))
de_train <- de1[dt,]
de_test <- de1[-dt,]
base_melding <- fnPredictMelding(depoint = de_train, de2, dppoint = de_test, dparea = NULL, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
base_down <- fnPredictDown(depoint = de_train, de2, dppoint = de_test, dparea = NULL, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
data <- st_join(base_melding,base_down)
final_melding <- fnPredictMelding(depoint = de1, de2, dppoint = dp1, dparea = dp2, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
final_down <- fnPredictDown(depoint = de1, de2, dppoint = dp1, dparea = dp2, boundaryregion,
mesh, priorspdesigma = prior1, priorspderange = prior2)[[1]]
newdata <- st_join(final_melding,final_down)
#standard CV
#----
if(SCV == F) {
regressControl  <- trainControl(method="repeatedcv",
number = 3,
repeats = 3
)
stack_regression_const <- train(
value ~ pred_mean.x + pred_mean.y, data = data, method = "lm",
tuneGrid  = expand.grid(intercept = FALSE),
trControl = regressControl,
tuneLength = 10
)
final_pred = predict(stack_regression_const, newdata = newdata)
}
#----
# spatial coefficients
#----
# Specify formula
if(SCV == T){
# mesh_ensem <- fnCreateMesh(data, boundaryregion)
#
# formula <- y ~ 0  + X1 + X2 + f(s, model = spde) + f(s1, model = spde)
#
# if(!is.null(prior1) & !is.null(prior2)){
#   fnCheckPrior(prior1, prior2)
#   spde <- inla.spde2.pcmatern(mesh = mesh_ensem, prior.range = prior2, prior.sigma = prior1)
# }else{
#   spde <- inla.spde2.matern(mesh = mesh_ensem, alpha = 2, constr = T)
# }
#
# indexs <- inla.spde.make.index("s", spde$n.spde)
# indexs1 <- inla.spde.make.index("s1", spde$n.spde)
#
# Ae <- inla.spde.make.A(mesh_ensem, loc = as.matrix(st_coordinates(data$geometry))[, c(1, 2)])
# Ap <- inla.spde.make.A(mesh = mesh_ensem, loc = as.matrix(st_coordinates(dp1$geometry)))
#
# stk.e <- inla.stack(tag = "est", data = list(y = data$value),
#                     A = list( Ae * data$pred_mean.x, Ae * data$pred_mean.y, Ae),
#                     effects = list(data.frame(X1 = data$pred_mean.x, X2 = data$pred_mean.y), s = indexs$s, s1 = indexs1$s1))
# stk.p <- inla.stack(tag = "pred2", data = list(y = NA),
#                     A = list( Ap * data$pred_mean.x, Ap * data$pred_mean.y, Ap ),
#                     effects = list(data.frame( X1 = data$pred_mean.x, X2 = data$pred_mean.y), s = indexs$s, s1 = indexs1$s1))
# # Call inla()
# res <- inla(formula, data = inla.stack.data(stk.full), control.predictor = list(compute = TRUE, A = inla.stack.A(stk.full)))
}
return(final_pred)
}
ensemble = fnPredictEnsemble(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
m3 = Metrics::mse(true,ensemble)
m1 <- inla(value ~ pred_mean.x + pred_mean.y + f(ID, model = "iid"),
data = data)
mesh_ensem <- fnCreateMesh(data, boundaryregion)
plot(mesh_ensem)
plot(mesh)
#
formula <- y ~ 0  + X1 + X2 + f(s, model = spde) + f(s1, model = spde)
spde <- inla.spde2.matern(mesh = mesh_ensem, alpha = 2, constr = T)
#
# if(!is.null(prior1) & !is.null(prior2)){
#   fnCheckPrior(prior1, prior2)
#   spde <- inla.spde2.pcmatern(mesh = mesh_ensem, prior.range = prior2, prior.sigma = prior1)
# }else{
#   spde <- inla.spde2.matern(mesh = mesh_ensem, alpha = 2, constr = T)
# }
#
indexs <- inla.spde.make.index("s", spde$n.spde)
indexs1 <- inla.spde.make.index("s1", spde$n.spde)
#
Ae <- inla.spde.make.A(mesh_ensem, loc = as.matrix(st_coordinates(data$geometry))[, c(1, 2)])
Ap <- inla.spde.make.A(mesh = mesh_ensem, loc = as.matrix(st_coordinates(dp1$geometry)))
#
stk.e <- inla.stack(tag = "est", data = list(y = data$value),
A = list( Ae * data$pred_mean.x, Ae * data$pred_mean.y, Ae),
effects = list(data.frame(X1 = data$pred_mean.x, X2 = data$pred_mean.y), s = indexs$s, s1 = indexs1$s1))
nrow(Ae)
nrow(indexs$s)
RFoptions(cores = 2)
mclapply(c(100, 1000), mysimulate, scale = 0.05,nu = 2, var = 1,mean = 10, anum = 2, N = 3)
RFoptions(LIST = l)
RandomFieldsUtils::RFoptions(LIST = l)
?RandomFieldsUtils::RFoption
RFoptions(spConform = F)
mclapply(c(100, 1000), mysimulate, scale = 0.05,nu = 2, var = 1,mean = 10, anum = 2, N = 3)
R <- ppp(x = runif(100), y = runif(100),c(0,1),c(0,1))
Win <- Window(R)
boundaryregion = st_as_sf(Win)%>%st_set_crs(crsproj)
crsproj = 4326
R <- ppp(x = runif(100), y = runif(100),c(0,1),c(0,1))
Win <- Window(R)
setwd("~/Documents/Project 1/simulation")
plot(boundaryregion)
?RandomFieldsUtils::RFoptions
mclapply(c(100, 1000), mysimulate, scale = 0.05,nu = 2, var = 1,mean = 10, anum = 2, N = 3,mc.cores = 2)
library(raster)
library(RandomFields)
library(spatstat)
library(stars)
library(sf)
library(ggplot2)
library(INLA)
library(caret)
library(glmnet)
setwd("~/Documents/Project 1/simulation")
source('samplegenerator.r')
setwd("~/Documents/Project 1/resources/sptialM")
source('fnPredictMelding.R')
source('fnPredictDown.R')
source('fnPredictEnsemble.R')
crsproj = 4326
R <- ppp(x = runif(100), y = runif(100),c(0,1),c(0,1))
Win <- Window(R)
boundaryregion = sf::st_as_sf(Win)%>%sf::st_set_crs(crsproj)
plot(boundaryregion)
bb <- unname(attributes(st_geometry(boundaryregion))$bbox)
# Grid
x <- seq(bb[1] - 0.1, bb[3] + 0.1, length.out = 50)
y <- seq(bb[2] - 0.1, bb[4] + 0.1, length.out = 50)
coop <- expand.grid(x, y)
coop_sf <- sf::st_as_sf(coop, coords = c('Var1','Var2'), crs = crsproj)
dpcontsurface <- coop_sf %>% st_join(boundaryregion, left = FALSE)
ggplot()+geom_sf(data = dpcontsurface)
dppoint = dpcontsurface
#----
# Generate surface
# Region study unit square
r <- raster(nrows = 100, ncols = 100, xmn = 0, xmx = 1, ymn = 0, ymx = 1)
x <- coordinates(r)[, 1]
y <- coordinates(r)[, 2]
#----
mysimulate <- function(scale, nu = 2, var, mean = 10, pnum, anum, N, unif = T){
for (i in 1: N){
M1 = NULL
M2 = NULL
M3 = NULL
model = RMwhittle(scale = scale,nu = nu, var = var)+RMtrend(mean = mean)
simu <- RFsimulate(model = model, x = x, y = y)
values(r) <- simu$variable1
if(unif == T) {p1 = punifsample(pnum,r, crsproj)}
if(unif == F) {p1 = pimsample(pnum,r, crsproj)}
a1 = areasample(anum, r, crsproj)
true <- raster::extract(r, as.matrix(st_coordinates(dppoint)))
mesh = fnCreateMesh(p1, boundaryregion)
meld = fnPredictMelding(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
down = fnPredictDown(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
ensemble = fnPredictEnsemble(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
m1 = Metrics::mse(true,meld[[1]]$pred_mean)
m2 = Metrics::mse(true,down[[1]]$pred_mean)
m3 = Metrics::mse(true,ensemble)
M1 = c(M1,m1)
M2 = c(M2,m2)
M3 = c(M3,m3)
}
return(list(M1, M2, M3))
}
mclapply(c(100, 1000), mysimulate, scale = 0.05,nu = 2, var = 1,mean = 10, anum = 2, N = 3,mc.cores = 2)
RFoptions(spConform = F,cores = 2)
View(fnCheckInputsMelding)
library(raster)
library(RandomFields)
library(spatstat)
library(stars)
library(sf)
library(ggplot2)
library(INLA)
library(caret)
library(glmnet)
setwd("~/Documents/Project 1/simulation")
source('samplegenerator.r')
setwd("~/Documents/Project 1/resources/sptialM")
source('fnPredictMelding.R')
source('fnPredictDown.R')
source('fnPredictEnsemble.R')
crsproj = 4326
R <- ppp(x = runif(100), y = runif(100),c(0,1),c(0,1))
Win <- Window(R)
boundaryregion = sf::st_as_sf(Win)%>%sf::st_set_crs(crsproj)
plot(boundaryregion)
bb <- unname(attributes(st_geometry(boundaryregion))$bbox)
# Grid
x <- seq(bb[1] - 0.1, bb[3] + 0.1, length.out = 50)
y <- seq(bb[2] - 0.1, bb[4] + 0.1, length.out = 50)
coop <- expand.grid(x, y)
coop_sf <- sf::st_as_sf(coop, coords = c('Var1','Var2'), crs = crsproj)
dpcontsurface <- coop_sf %>% st_join(boundaryregion, left = FALSE)
ggplot()+geom_sf(data = dpcontsurface)
dppoint = dpcontsurface
mysimulate <- function(scale, nu = 2, var, mean = 10, pnum, anum, N, unif = T){
for (i in 1: N){
M1 = NULL
M2 = NULL
M3 = NULL
model = RMwhittle(scale = scale,nu = nu, var = var)+RMtrend(mean = mean)
simu <- RFsimulate(model = model, x = x, y = y)
values(r) <- simu$variable1
if(unif == T) {p1 = punifsample(pnum,r, crsproj)}
if(unif == F) {p1 = pimsample(pnum,r, crsproj)}
a1 = areasample(anum, r, crsproj)
true <- raster::extract(r, as.matrix(st_coordinates(dppoint)))
mesh = fnCreateMesh(p1, boundaryregion)
meld = fnPredictMelding(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
down = fnPredictDown(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
ensemble = fnPredictEnsemble(depoint = p1, dearea = a1,
dppoint = dppoint,
dparea = NULL,
boundaryregion = boundaryregion, mesh = mesh)
m1 = Metrics::mse(true,meld[[1]]$pred_mean)
m2 = Metrics::mse(true,down[[1]]$pred_mean)
m3 = Metrics::mse(true,ensemble)
M1 = c(M1,m1)
M2 = c(M2,m2)
M3 = c(M3,m3)
}
return(list(M1, M2, M3))
}
as.im(r)
scale = 0.05
nu = 2
var = 1
mean = 10
pnum = 100
anum = 2
model = RMwhittle(scale = scale,nu = nu, var = var)+RMtrend(mean = mean)
simu <- RFsimulate(model = model, x = x, y = y)
values(r) <- simu$variable1
simu <- RFsimulate(model = model, x = x, y = y)
View(simu)
